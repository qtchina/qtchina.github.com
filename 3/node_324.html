
<!DOCTYPE HTML>
<html>
<head>
<meta charset='utf8'>
<title>PHP真正的多进程运行模式</title>
</head>
<body>
使用PHP真正的多进程运行模式，适用于数据采集、邮件群发、数据源更新、tcp服务器等环节。<br />
下载地址 http://code.google.com/p/signfork/downloads/list<br />
<br />
运行条件：*NUX环境、 编译时需要 --enable-pcntl    posix扩展<br />
<br />
<br />
以下是主程序文件：<br />
<code type="php"><br />
<?php<br />
/**<br />
* Project: Signfork: php多线程库<br />
* File:    Signfork.class.php<br />
*<br />
* @link        [url]http://code.google.com/p/signfork/[/url]<br />
* @author        lajabs <hittyo at gmail dot com> QQ:124321697<br />
* @version 1.0.0 2009/8/4<br />
*/<br />
<br />
<br />
<br />
class Signfork<br />
{<br />
        /**<br />
     * 设置子进程通信文件所在目录<br />
     * @var string<br />
     */<br />
        private $tmp_path='/tmp/';<br />
<br />
        /**<br />
     * Signfork引擎主启动方法<br />
         * 1、判断$arg类型,类型为数组时将值传递给每个子进程;类型为数值型时,代表要创建的进程数.<br />
         * @param object $obj 执行对象<br />
         * @param string|array $arg 用于对象中的__fork方法所执行的参数<br />
         * 如:$arg,自动分解为:$obj->__fork($arg[0])、$obj->__fork($arg[1])...<br />
         * @return array  返回   array(子进程序列=>子进程执行结果);<br />
     */<br />
        public function run($obj,$arg=1)<br />
        {<br />
                if(!method_exists($obj,'__fork'))<br />
                {<br />
                        exit("Method '__fork' not found!");<br />
                }<br />
<br />
                if(is_array($arg))<br />
                {<br />
                        $i=0;<br />
                        foreach($arg as $key=>$val)<br />
                        {<br />
                                $spawns[$i]=$key;<br />
                                $i++;<br />
                                $this->spawn($obj,$key,$val);<br />
                        }<br />
                        $spawns['total']=$i;<br />
                }<br />
                elseif($spawns=intval($arg))<br />
                {<br />
                        for($i = 0; $i < $spawns; $i++) <br />
                        {<br />
                                $this->spawn($obj,$i);<br />
                        }<br />
                }<br />
                else<br />
                {<br />
                        exit('Bad argument!');<br />
                }<br />
                if($i>1000) exit('Too many spawns!');<br />
<br />
                return $this->request($spawns);<br />
        }<br />
<br />
<br />
        /**<br />
     * Signfork主进程控制方法<br />
         * 1、$tmpfile 判断子进程文件是否存在，存在则子进程执行完毕，并读取内容<br />
         * 2、$data收集子进程运行结果及数据，并用于最终返回<br />
         * 3、删除子进程文件<br />
         * 4、轮询一次0.03秒，直到所有子进程执行完毕，清理子进程资源<br />
         * @param  string|array $arg 用于对应每个子进程的ID<br />
         * @return array  返回   array([子进程序列]=>[子进程执行结果]);<br />
     */<br />
        private function request($spawns)<br />
        {<br />
                $data=array();<br />
                $i=is_array($spawns)?$spawns['total']:$spawns;<br />
                for($ids = 0; $ids<$i; $ids++)<br />
                {<br />
                        while(!($cid=pcntl_waitpid(-1, $status, WNOHANG)))usleep(30000);<br />
                        $tmpfile=$this->tmp_path.'sfpid_'.$cid;<br />
                        $data[$spawns['total']?$spawns[$ids]:$ids]=file_get_contents($tmpfile);<br />
                        unlink($tmpfile);<br />
                }<br />
                return $data;<br />
        }<br />
<br />
        /**<br />
     * Signfork子进程执行方法<br />
         * 1、pcntl_fork 生成子进程<br />
         * 2、file_put_contents 将'$obj->__fork($val)'的执行结果存入特定序列命名的文本<br />
         * 3、posix_kill杀死当前进程<br />
         * @param object $obj        待执行的对象<br />
         * @param object $i                子进程的序列ID，以便于返回对应每个子进程数据<br />
         * @param object $param 用于输入对象$obj方法'__fork'执行参数<br />
     */<br />
        private function spawn($obj,$i,$param=null)<br />
        {<br />
                if(pcntl_fork()===0)<br />
                {<br />
                        $cid=getmypid();<br />
                        file_put_contents($this->tmp_path.'sfpid_'.$cid,$obj->__fork($param));<br />
                        posix_kill($cid, SIGTERM);<br />
                        exit;<br />
                }<br />
        }<br />
}<br />
<br />
?><br />
</code><br />
<br />
<code type="php"><br />
<?php<br />
include('Signfork.class.php');<br />
<br />
class test<br />
{<br />
        function __fork($arg)<br />
        {<br />
                return file_get_contents($arg);<br />
        }<br />
}<br />
<br />
$limit                =microtime(true);<br />
$test                =new test();<br />
$Signfork        =new Signfork();<br />
<br />
<br />
<br />
$arg=array(<br />
'http://yahoo.com',<br />
'http://baidu.com',<br />
'http://google.com',<br />
'http://qq.com',<br />
'http://163.com',<br />
'http://sina.com'<br />
);<br />
<br />
<br />
$Signfork->run($test,$arg);<br />
echo 'Run time:'.(microtime(true)-$limit); <br />
?><br />
<br />
</code><br />
<br />
输出：<br />
Run time:1.3541439928133<br />
<br />
整体运行时间在一秒左右，说明多进程发挥了重要作用。
</body>
</html>
