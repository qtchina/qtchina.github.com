<!DOCTYPE HTML>
<html>
    <head>
        <meta charset='utf8'>
        <title>海量数据处理之Bloom Filter详解</title>
        <link rel="stylesheet" href="../css/base.css" type="text/css" />
    </head>
<body>

<table width="80%" height="80 px" align="center">
  <tr>
    <td>
      <div id="branding"><strong><a href="/">
        <img src="../images/nullget_labs.gif" alt="www.qtchina.net " title="www.qtchina.net " id="logo" />
        <span>www.qtchina.net</span>            </a></strong></div>
      </div>
    </td>
  </tr>
</table>

<table width="80%" align="center">
  <tr>
    <td>
      <h2>海量数据处理之Bloom Filter详解</h2>
    </td>
  </tr>

  <tr>
    <td>
      发布： 2011-12-12 14:19
    </td>
  </tr>

  <tr>
    <td width="50%">
      <br />
<h3>前言</h3> <p>&nbsp;&nbsp;&nbsp; 本博客内曾已经整理过<a href="http://blog.csdn.net/v_JULY_v/archive/2011/03/26/6279498.aspx" target="_blank">十道海量数据处理面试题与十个方法大总结</a>。接下来，本博客内会重点分析那些海量数据处理的方法，并重写十道海量数据处理的面试题。如果有任何问题，欢迎不吝指正。谢谢。</p> <h3>一、什么是Bloom Filter</h3> <p><span style="font-size:16px"><span style="font-family:Times New Roman">&nbsp;&nbsp;&nbsp; Bloom Filter</span>是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。<span style="font-family:Times New Roman">Bloom Filter</span>的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（<span style="font-family:Times New Roman">false positive</span>）。因此，<span style="font-family:Times New Roman">Bloom Filter</span>不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，<span style="font-family:Times New Roman">Bloom Filter</span>通过极少的错误换取了存储空间的极大节省。</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 有人可能想知道它的中文叫法，倒是有被译作称布隆过滤器。该不该译，译的是否恰当，由诸君品之。下文之中，如果有诸多公式不慎理解，也无碍，只作稍稍了解即可。</span></p> <h4>1.1、集合表示和元素查询</h4> <span style="font-family:'Courier New'"></span> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 下面我们具体来看<span style="font-family:Times New Roman">Bloom Filter</span>是如何用位数组表示集合的。初始状态时，<span style="font-family:Times New Roman">Bloom Filter</span>是一个包含<span style="font-family:Times New Roman">m</span>位的位数组，每一位都置为<span style="font-family:Times New Roman">0</span>。</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf1.jpg"></span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 为了表达<span style="font-family:Times New Roman">S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}</span>这样一个<span style="font-family:Times New Roman">n</span>个元素的集合，<span style="font-family:Times New Roman">Bloom Filter</span>使用<span style="font-family:Times New Roman">k</span>个相互独立的哈希函数（<span style="font-family:Times New Roman">Hash Function</span>），它们分别将集合中的每个元素映射到<span style="font-family:Times New Roman">{1,…,m}</span>的范围中。对任意一个元素<span style="font-family:Times New Roman">x</span>，第<span style="font-family:Times New Roman">i</span>个哈希函数映射的位置<span style="font-family:Times New Roman">h<sub>i</sub>(x)</span>就会被置为<span style="font-family:Times New Roman">1</span>（<span style="font-family:Times New Roman">1</span>≤<span style="font-family:Times New Roman">i</span>≤<span style="font-family:Times New Roman">k</span>）。注意，如果一个位置多次被置为<span style="font-family:Times New Roman">1</span>，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，<span style="font-family:Times New Roman">k=3</span>，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。</span><span style="font-size:16px">&nbsp;&nbsp;&nbsp;</span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf2.jpg"></p> <p><span style="font-family:Times New Roman; font-size:16px">&nbsp;</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 在判断<span style="font-family:Times New Roman">y</span>是否属于这个集合时，我们对<span style="font-family:Times New Roman">y</span>应用<span style="font-family:Times New Roman">k</span>次哈希函数，如果所有<span style="font-family:Times New Roman">h<sub>i</sub>(y)</span>的位置都是<span style="font-family:Times New Roman">1</span>（<span style="font-family:Times New Roman">1</span>≤<span style="font-family:Times New Roman">i</span>≤<span style="font-family:Times New Roman">k</span>），那么我们就认为<span style="font-family:Times New Roman">y</span>是集合中的元素，否则就认为<span style="font-family:Times New Roman">y</span>不是集合中的元素。下图中<span style="font-family:Times New Roman">y<sub>1</sub></span>就不是集合中的元素（因为y1有一处指向了“0”位）。<span style="font-family:Times New Roman">y<sub>2</sub></span>或者属于这个集合，或者刚好是一个<span style="font-family:Times New Roman">false positive</span>。</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf3.jpg"></span></p> <span style="font-family:Times New Roman"></span> <h4>1.2、错误率估计</h4> <span style="font-family:'Courier New'"></span> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 前面我们已经提到了，<span style="font-family:Times New Roman">Bloom Filter</span>在判断一个元素是否属于它表示的集合时会有一定的错误率（<span style="font-family:Times New Roman">false positive rate</span>），下面我们就来估计错误率的大小。在估计之前为了简化模型，我们假设<span style="font-family:Times New Roman">kn&lt;m</span>且各个哈希函数是完全随机的。当集合<span style="font-family:Times New Roman">S={x<sub>1</sub>, x<sub>2</sub>,…,x<sub>n</sub>}</span>的所有元素都被<span style="font-family:Times New Roman">k</span>个哈希函数映射到<span style="font-family:Times New Roman">m</span>位的位数组中时，这个位数组中某一位还是<span style="font-family:Times New Roman">0</span>的概率是：</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf4.jpg"></span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 其中<span style="font-family:Times New Roman">1/m</span>表示任意一个哈希函数选中这一位的概率（前提是哈希函数是完全随机的），<span style="font-family:Times New Roman">(1-1/m)</span>表示哈希一次没有选中这一位的概率。要把<span style="font-family:Times New Roman">S</span>完全映射到位数组中，需要做<span style="font-family:Times New Roman">kn</span>次哈希。某一位还是<span style="font-family:Times New Roman">0</span>意味着<span style="font-family:Times New Roman">kn</span>次哈希都没有选中它，因此这个概率就是（<span style="font-family:Times New Roman">1-1/m</span>）的<span style="font-family:Times New Roman">kn</span>次方。令<span style="font-family:Times New Roman">p = e<sup>-kn/m</sup></span>是为了简化运算，这里用到了计算e时常用的近似：</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf16.JPG"></span></p> <p align="center">&nbsp;</p> <p><span style="font-size:16px">令ρ为位数组中<span style="font-family:Times New Roman">0</span>的比例，则ρ的数学期望E(ρ)=<span style="font-family:Times New Roman"> p’</span>。在ρ已知的情况下，要求的错误率（<span style="font-family:Times New Roman">false positive rate</span>）为：</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf5.jpg"></span></p> <p><span style="font-size:16px"><span style="font-family:Times New Roman">(1-</span>ρ)为位数组中<span style="font-family:Times New Roman">1</span>的比例，<span style="font-family:Times New Roman">(1-</span>ρ)<sup>k</sup>就表示<span style="font-family:Times New Roman">k</span>次哈希都刚好选中<span style="font-family:Times New Roman">1</span>的区域，即<span style="font-family:Times New Roman">false positive rate</span>。上式中第二步近似在前面已经提到了，现在来看第一步近似。<span style="font-family:Times New Roman">p’</span>只是ρ的数学期望，在实际中ρ的值有可能偏离它的数学期望值。<span style="font-family:Times New Roman">M. Mitzenmacher</span>已经证明<sup><span style="font-family:Times New Roman">[2]</span></sup> ，位数组中0的比例非常集中地分布在它的数学期望值的附近。因此，第一步的近似得以成立。分别将<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">p’</span>代入上式中，得：</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; </span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf6.jpg"></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf7.jpg"></p> <p><span style="font-size:16px">相比<span style="font-family:Times New Roman">p’</span>和<span style="font-family:Times New Roman">f’</span>，使用<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>通常在分析中更为方便。</span></p> <span style="font-family:Times New Roman"></span> <h4>1.3、最优的哈希函数个数</h4> <span style="font-family:'Courier New'"></span> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 既然<span style="font-family:Times New Roman">Bloom Filter</span>要靠多个哈希函数将集合映射到位数组中，那么应该选择几个哈希函数才能使元素查询时的错误率降到最低呢？这里有两个互斥的理由：如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到<span style="font-family:Times New Roman">0</span>的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的<span style="font-family:Times New Roman">0</span>就多。为了得到最优的哈希函数个数，我们需要根据上一小节中的错误率公式进行计算。</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 先用<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>进行计算。注意到<span style="font-family:Times New Roman">f = exp(k ln(1 − e<sup>−kn/m</sup>))</span>，我们令<span style="font-family:Times New Roman">g = k ln(1 − e<sup>−kn/m</sup>)</span>，只要让<span style="font-family:Times New Roman">g</span>取到最小，<span style="font-family:Times New Roman">f</span>自然也取到最小。由于<span style="font-family:Times New Roman">p = e<sup>-kn/m</sup></span>，我们可以将<span style="font-family:Times New Roman">g</span>写成</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf8.jpg"></span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 根据对称性法则可以很容易看出当<span style="font-family:Times New Roman">p = 1/2</span>，也就是<span style="font-family:Times New Roman">k = ln2· (m/n)</span>时，<span style="font-family:Times New Roman">g</span>取得最小值。在这种情况下，最小错误率<span style="font-family:Times New Roman">f</span>等于<span style="font-family:Times New Roman">(1/2)<sup>k</sup></span>≈<span style="font-family:Times New Roman"> (0.6185)<sup>m/n</sup></span>。另外，注意到p是位数组中某一位仍是0的概率，所以<span style="font-family:Times New Roman">p = 1/2</span><span style="font-family:Times New Roman">对应着位数组中0和1各一半。换句话说，要想保持错误率低，最好让位数组有一半还空着。</span></span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 需要强调的一点是，<span style="font-family:Times New Roman">p = 1/2</span>时错误率最小这个结果并不依赖于近似值<span style="font-family:Times New Roman">p</span>和<span style="font-family:Times New Roman">f</span>。同样对于<span style="font-family:Times New Roman">f’ = exp(k ln(1 − (1 − 1/m)<sup>kn</sup>))</span>，<span style="font-family:Times New Roman">g’ = k ln(1 − (1 − 1/m)<sup>kn</sup>)</span>，<span style="font-family:Times New Roman">p’ = (1 − 1/m)<sup>kn</sup></span>，我们可以将<span style="font-family:Times New Roman">g’</span>写成</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf9.jpg"></span></p> <p><span style="font-size:16px">同样根据对称性法则可以得到当<span style="font-family:Times New Roman">p’ = 1/2</span>时，<span style="font-family:Times New Roman">g’</span>取得最小值。</span></p> <span style="font-family:Times New Roman"></span> <h4>1.4、位数组的大小</h4> <span style="font-family:'Courier New'"></span> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 下面我们来看看，在不超过一定错误率的情况下，<span style="font-family:Times New Roman">Bloom Filter</span>至少需要多少位才能表示全集中任意<span style="font-family:Times New Roman">n</span>个元素的集合。假设全集中共有<span style="font-family:Times New Roman">u</span>个元素，允许的最大错误率为<span style="font-family:Times New Roman">є</span>，下面我们来求位数组的位数<span style="font-family:Times New Roman">m</span>。</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 假设<span style="font-family:Times New Roman">X</span>为全集中任取<span style="font-family:Times New Roman">n</span>个元素的集合，<span style="font-family:Times New Roman">F(X)</span>是表示<span style="font-family:Times New Roman">X</span>的位数组。那么对于集合<span style="font-family:Times New Roman">X</span>中任意一个元素<span style="font-family:Times New Roman">x</span>，在<span style="font-family:Times New Roman">s = F(X)</span>中查询<span style="font-family:Times New Roman">x</span>都能得到肯定的结果，即<span style="font-family:Times New Roman">s</span>能够接受<span style="font-family:Times New Roman">x</span>。显然，由于<span style="font-family:Times New Roman">Bloom Filter</span>引入了错误，<span style="font-family:Times New Roman">s</span>能够接受的不仅仅是<span style="font-family:Times New Roman">X</span>中的元素，它还能够<span style="font-family:Times New Roman">є (u - n)</span>个<span style="font-family:Times New Roman">false positive</span>。因此，对于一个确定的位数组来说，它能够接受总共<span style="font-family:Times New Roman">n + є (u - n)</span>个元素。在<span style="font-family:Times New Roman">n + є (u - n)</span>个元素中，<span style="font-family:Times New Roman">s</span>真正表示的只有其中<span style="font-family:Times New Roman">n</span>个，所以一个确定的位数组可以表示</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf10.jpg"></span></p> <p><span style="font-size:16px">个集合。<span style="font-family:Times New Roman">m</span>位的位数组共有<span style="font-family:Times New Roman">2<sup>m</sup></span>个不同的组合，进而可以推出，<span style="font-family:Times New Roman">m</span>位的位数组可以表示</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; </span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf11.jpg"></p> <p><span style="font-size:16px">个集合。全集中<span style="font-family:Times New Roman">n</span>个元素的集合总共有</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; </span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf12.jpg"></p> <p><span style="font-size:16px">个，因此要让<span style="font-family:Times New Roman">m</span>位的位数组能够表示所有<span style="font-family:Times New Roman">n</span>个元素的集合，必须有</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; </span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf13.jpg"></p> <p><span style="font-size:16px">即：</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; </span></p> <p align="center"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf14.jpg"></p> <p><span style="font-size:16px">上式中的近似前提是<span style="font-family:Times New Roman">n</span>和<span style="font-family:Times New Roman">єu</span>相比很小，这也是实际情况中常常发生的。根据上式，我们得出结论：在错误率不大于<span style="font-family:Times New Roman">є</span>的情况下，<span style="font-family:Times New Roman">m</span>至少要等于<span style="font-family:Times New Roman">n log<sub>2</sub>(1/є)</span>才能表示任意<span style="font-family:Times New Roman">n</span>个元素的集合。</span></p> <p>&nbsp;</p> <p><span style="font-size:16px">上一小节中我们曾算出当<span style="font-family:Times New Roman">k = ln2· (m/n)</span>时错误率<span style="font-family:Times New Roman">f</span>最小，这时<span style="font-family:Times New Roman">f = (1/2)<sup>k</sup>= (1/2)<sup>mln2 / n</sup></span>。现在令<span style="font-family:Times New Roman">f</span>≤<span style="font-family:Times New Roman">є</span>，可以推出</span></p> <p align="center"><span style="font-size:16px"><img alt="" src="http://p.blog.csdn.net/images/p_blog_csdn_net/jiaomeng/275417/o_bf15.jpg"></span></p> <p><span style="font-size:16px">这个结果比前面我们算得的下界<span style="font-family:Times New Roman">n log<sub>2</sub>(1/є)</span>大了<span style="font-family:Times New Roman">log<sub>2</sub>e</span>≈<span style="font-family:Times New Roman"> 1.44</span>倍。这说明在哈希函数的个数取到最优时，要让错误率不超过<span style="font-family:Times New Roman">є</span>，<span style="font-family:Times New Roman">m</span>至少需要取到最小值的<span style="font-family:Times New Roman">1.44</span>倍。</span></p> <span style="font-family:Times New Roman"></span> <h4>1.5、概括</h4> <span style="font-family:'Courier New'"></span> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。<span style="font-family:Times New Roman">Bloom Filter</span>在时间空间这两个因素之外又引入了另一个因素：错误率。在使用<span style="font-family:Times New Roman">Bloom Filter</span>判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（<span style="font-family:Times New Roman">False Positive</span>），但不会把属于这个集合的元素误认为不属于这个集合（<span style="font-family:Times New Roman">False Negative</span>）。在增加了错误率这个因素之后，<span style="font-family:Times New Roman">Bloom Filter</span>通过允许少量的错误来节省大量的存储空间。</span></p> <p><span style="font-size:16px">&nbsp;&nbsp;&nbsp; 自从<span style="font-family:Times New Roman">Burton Bloom</span>在<span style="font-family:Times New Roman">70</span>年代提出<span style="font-family:Times New Roman">Bloom Filter</span>之后，<span style="font-family:Times New Roman">Bloom Filter</span>就被广泛用于拼写检查和数据库系统中。近一二十年，伴随着网络的普及和发展，<span style="font-family:Times New Roman">Bloom Filter</span>在网络领域获得了新生，各种<span style="font-family:Times New Roman">Bloom Filter</span>变种和新的应用不断出现。可以预见，随着网络应用的不断深入，新的变种和应用将会继续出现，<span style="font-family:Times New Roman">Bloom Filter</span>必将获得更大的发展。</span></p> <h3>二、适用范围</h3> <p><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; 可以用来实现数据字典，进行数据的判重，或者集合求交集&nbsp;</span></span></p> <h3>三、基本原理及要点</h3> <div><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; 对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这 个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。&nbsp;</span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'"><br> </span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; 还有一个比较重要的问题，如 何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)*(m/n)时错误率最小。在错误率不大于E的情况 下，m至少要等于n*lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应 该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。&nbsp;</span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'"><br> </span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'">举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。&nbsp;</span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'"><br> </span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; 注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。&nbsp;</span></span></div> <div>&nbsp;</div> <h3>四、扩展</h3> <div><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。&nbsp;</span></span></div> <div>&nbsp;</div> <h3>五、问题实例</h3> <div><span style="font-size:14px"><span style="font-family:'Courier New'">&nbsp;&nbsp;&nbsp; 给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？&nbsp;</span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'"><br> </span></span></div> <div><span style="font-size:14px"><span style="font-family:'Courier New'">根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。 现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。&nbsp;</span></span></div> <div><span style="font-size:14px"></span>&nbsp;</div> <div><span style="font-size:14px"><span style="font-family:Courier New">以上内容整理自：</span></span></div> <ol> <li><span style="font-size:14px"><span style="font-family:Courier New"><a href="http://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank">http://blog.csdn.net/jiaomeng/article/details/1495500</a></span></span></li><li><span style="font-size:14px"><a href="http://blog.redfox66.com/post/2010/09/24/mass-data-topic-1-start.aspx" target="_blank">http://blog.redfox66.com/post/2010/09/24/mass-data-topic-1-start.aspx</a>。</span></li></ol> <p><span style="font-size:14px">完。</span></p> 引用： http://blog.csdn.net/v_july_v/article/details/6685894/
    </td>
  </tr>
  <tr>
    <td>
      <br /><br />
      原文： <a href='http://nullget.sourceforge.net/?q=node/622'>http://nullget.sourceforge.net/?q=node/622</a>
    </td>
  </tr>

</table>

<p></p>
<p></p>
<p></p>
<table width="60%"><tr><td  align="center">
  <div>
    <span>Powered by <a href="http://nullget.sourceforge.net">zexport</a></span>  </div>
  </div>
  </td></tr></table>

<br />
<div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51467019-1', 'qtchina.github.io');
  ga('send', 'pageview');

</script>

</div>
</body>
</html>
