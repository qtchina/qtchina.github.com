<!DOCTYPE HTML>
<html>
    <head>
        <meta charset='utf8'>
        <title>教你初步了解 KMP 算法</title>
        <link rel="stylesheet" href="../css/base.css" type="text/css" />
    </head>
<body>

<table width="80%" height="80 px" align="center">
  <tr>
    <td>
      <div id="branding"><strong><a href="/">
        <img src="../images/nullget_labs.gif" alt="www.qtchina.net " title="www.qtchina.net " id="logo" />
        <span>www.qtchina.net</span>            </a></strong></div>
      </div>
    </td>
  </tr>
</table>

<table width="80%" align="center">
  <tr>
    <td>
      <h2>教你初步了解 KMP 算法</h2>
    </td>
  </tr>

  <tr>
    <td>
      发布： 2011-12-13 12:04
    </td>
  </tr>

  <tr>
    <td width="50%">
      <br />
<div id="article_content" class="article_content"><div class="Section0" style="layout-grid:15.6pt none"> </div> <p>本文参考：数据结构（c语言版） 李云清等编著、算法导论</p> <p> 引言： <br> 在文本编辑中，我们经常要在一段文本中某个特定的位置找出 某个特定的字符或模式。 <br> 由此，便产生了字符串的匹配问题。 <br> 本文由简单的字符串匹配算法开始，再到KMP算法，由浅入深，教你从头到尾彻底理解KMP算法。 </p> <p> 来看算法导论一书上关于此字符串问题的定义： <br> 假设文本是一个长度为n的数组T[1...n]，模式是一个长度为m&lt;=n的数组P[1....m]。 <br> 进一步假设P和T的元素都是属于有限字母表Σ.中的字符。 </p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_1293869699IB0S.jpg" width="507" height="129"> </p> <p> 依据上图，再来解释下字符串匹配问题。目标是找出所有在文本T=abcabaabcaabac中的模式P=abaa所有出现。 <br> 该模式仅在文本中出现了一次，在位移s=3处。位移s=3是有效位移。 </p> <p> </p> <p> <span style="font-size:13px"> <span style="color:#800000"> <span style="font-size:16px">第一节、简单的字符串匹配算法</span> </span> </span> </p> <p> 简单的字符串匹配算法用一个循环来找出所有有效位移， <br> 该循环对n-m+1个可能的每一个s值检查条件P[1....m]=T[s+1....s+m]。 </p> <p> NAIVE-STRING-MATCHER(T, P) <br> 1 n ← length[T] <br> 2 m ← length[P] <br> 3 for s ← 0 to n - m <br> 4 do if P[1 ‥ m] = T[s + 1 ‥ s + m] <br> //对n-m+1个可能的位移s中的每一个值，比较相应的字符的循环必须执行m次。 <br> 5 then print "Pattern occurs with shift" s </p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_1293869974N093.jpg" width="434" height="119"> </p> <p> 简单字符串匹配算法，上图针对文本T=acaabc 和模式P=aab。 <br> 上述第4行代码，n-m+1个可能的位移s中的每一个值，比较相应的字符的循环必须执行m次。 <br> 所以，在最坏情况下，此简单模式匹配算法的运行时间为O（(n-m+1)m）。 </p> <p> </p> <p>--------------------------------</p> <p> 下面我再来举个具体例子，并给出一具体运行程序： <br> 对于目的字串target是banananobano,要匹配的字串pattern是nano,的情况， </p> <p> 下面是匹配过程，原理很简单，只要先和target字串的第一个字符比较， <br> 如果相同就比较下一个，如果不同就把pattern右移一下， <br> 之后再从pattern的每一个字符比较，这个算法的运行过程如下图。 <br> //index表示的每n次匹配的情形。 </p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_1293870405jSo5.jpg" width="540" height="400"> </p> <p> #include&lt;iostream&gt; <br> #include&lt;string&gt; <br> using namespace std; <br> int match(const string&amp; target,const string&amp; pattern) <br> { <br> int target_length = target.size(); <br> int pattern_length = pattern.size(); <br> int target_index = 0; <br> int pattern_index = 0; <br> while(target_index &lt; target_length &amp;&amp; pattern_index &lt; pattern_length) <br> { <br> if(target[target_index]==pattern[pattern_index]) <br> { <br> ++target_index; <br> ++pattern_index; <br> } <br> else <br> { <br> target_index -= (pattern_index-1); <br> pattern_index = 0; <br> } <br> } <br> if(pattern_index == pattern_length) <br> { <br> return target_index - pattern_length; <br> } <br> else <br> { <br> return -1; <br> } <br> } <br> int main() <br> { <br> cout&lt;&lt;match("banananobano","nano")&lt;&lt;endl; <br> return 0; <br> } </p> <p>//运行结果为4。</p> <p> </p> <p> 上面的算法进间复杂度是O(pattern_length*target_length), <br> 我们主要把时间浪费在什么地方呢， <br> 观查index =2那一步，我们已经匹配了3个字符，而第4个字符是不匹配的，这时我们已经匹配的字符序列是nan, </p> <p> 此时如果向右移动一位，那么nan最先匹配的字符序列将是an,这肯定是不能匹配的， <br> 之后再右移一位，匹配的是nan最先匹配的序列是n,这是可以匹配的。 </p> <p> 如果我们事先知道pattern本身的这些信息就不用每次匹配失败后都把target_index回退回去， <br> 这种回退就浪费了很多不必要的时间，如果能事先计算出pattern本身的这些性质， <br> 那么就可以在失配时直接把pattern移动到下一个可能的位置， <br> 把其中根本不可能匹配的过程省略掉， <br> 如上表所示我们在index=2时失配，此时就可以直接把pattern移动到index=4的状态， <br> kmp算法就是从此出发。 </p> <p> </p> <p> <span style="font-size:13px"> <span style="color:#800000"> <span style="font-size:16px">第二节、KMP算法</span> </span> </span> </p> <p> <strong> <span style="color:black"> <span style="font-family:Calibri">2.1、 </span> </span> <span style="font-family:宋体; color:black">覆盖函数</span> <span style="color:black"> <span style="font-family:Calibri">(overlay_function)</span> </span> </strong> </p> <p> 覆盖函数所表征的是pattern本身的性质，可以让为其表征的是pattern从左开始的所有连续子串的自我覆盖程度。 <br> 比如如下的字串，abaabcaba </p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_1293874441hilM.jpg" width="236" height="294"> </p> <p>由于计数是从0始的，因此覆盖函数的值为0说明有1个匹配，对于从0还是从来开始计数是偏好问题，</p> <p>具体请自行调整，其中-1表示没有覆盖，那么何为覆盖呢，下面比较数学的来看一下定义，比如对于序列</p> <p> </p> <div class="Section0" style="layout-grid:15.6pt none"> <p class="p0" style="margin-top:0pt; padding-left:30px; margin-bottom:0pt"> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">0</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">1...</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-1 </span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j</span> </p> <p class="p0" style="margin-top:0pt; padding-left:30px; margin-bottom:0pt"> </p> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal"></span> <p class="p0" style="margin-top:0pt; padding-left:30px; margin-bottom:0pt"> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal"> <span style="font-family:宋体">要找到一个</span> <span lang="EN-US"> <span style="font-family:Calibri">k,</span> </span> <span style="font-family:宋体">使它满足</span> </span> </p> <p class="p0" style="margin-top:0pt; padding-left:30px; margin-bottom:0pt"> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">0</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">1...</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">k-1</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">k=</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-k</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-k+1...</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-1</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j</span> </p> </div> <p> 而没有更大的k满足这个条件，就是说要找到尽可能大k,使pattern前k字符与后k字符相匹配，k要尽可能的大， <br> 原因是如果有比较大的k存在，而我们选择较小的满足条件的k， <br> 那么当失配时，我们就会使pattern向右移动的位置变大，而较少的移动位置是存在匹配的，这样我们就会把可能匹配的结果丢失。 </p><p>它本质上是找到即是模式串p的前缀，又是它的后缀的最长字符串。</p> <p>比如下面的序列，</p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_1293874442uL1u.jpg" width="537" height="122"> </p> <p> 在红色部分失配，正确的结果是k=1的情况，把pattern右移4位，如果选择k=0,右移5位则会产生错误。 <br> 计算这个overlay函数的方法可以采用递推，可以想象如果对于pattern的前j个字符，如果覆盖函数值为k </p> <p class="p0" style="margin-top:0pt; margin-bottom:0pt"> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">0</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">1...</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">k-1</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">k=</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-k</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-k+1...</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j-1</span> <span style="font-family:'宋体'; font-size:22pt; font-weight:normal">a</span> <span style="font-family:'宋体'; font-size:10.5pt; font-weight:normal">j</span> <br> 则对于pattern的前j+1序列字符，则有如下可能 <br> ⑴ pattern[k+1]==pattern[j+1] 此时overlay(j+1)=k+1=overlay(j)+1 <br> ⑵ pattern[k+1]≠pattern[j+1] 此时只能在pattern前k+1个子符组所的子串中找到相应的overlay函数，h=overlay(k),如果此时pattern[h+1]==pattern[j+1],则overlay(j+1)=h+1否则重复(2)过程. </p> <p class="p0" style="margin-top:0pt; margin-bottom:0pt"> </p> <p class="p0" style="margin-top:0pt; margin-bottom:0pt">下面给出一段计算覆盖函数的代码：</p> <p class="p0" style="margin-top:0pt; margin-bottom:0pt"> #include&lt;iostream&gt; <br> #include&lt;string&gt; <br> using namespace std; <br> void compute_overlay(const string&amp; pattern) <br> { <br> const int pattern_length = pattern.size(); <br> int *overlay_function = new int[pattern_length]; <br> int index; <br> overlay_function[0] = -1; <br> for(int i=1;i&lt;pattern_length;++i) <br> { <br> index = overlay_function[i-1]; <br> //store previous fail position k to index; <br> <br> while(index&gt;=0 &amp;&amp; pattern[i]!=pattern[index+1]) <br> { <br> index = overlay_function[index]; <br> } <br> if(pattern[i]==pattern[index+1]) <br> { <br> overlay_function[i] = index + 1; <br> } <br> else <br> { <br> overlay_function[i] = -1; <br> } <br> } <br> for(i=0;i&lt;pattern_length;++i) <br> { <br> cout&lt;&lt;overlay_function[i]&lt;&lt;endl; <br> } <br> delete[] overlay_function; <br> } <br> int main() <br> { <br> string pattern = "abaabcaba"; <br> compute_overlay(pattern); <br> return 0; <br> } </p> <p> </p> <p> </p> <p>运行结果为：</p> <p> -1 <br> -1 <br> 0 <br> 0 <br> 1 <br> -1 <br> 0 <br> 1 <br> 2 <br> Press any key to continue </p> <p>-------------------------------------</p> <p> </p> <p> <strong> 2.2、kmp算法 <br> </strong> 有了覆盖函数，那么实现kmp算法就是很简单的了，我们的原则还是从左向右匹配，但是当失配发生时，我们不用把target_index向回移动，target_index前面已经匹配过的部分在pattern自身就能体现出来，只要动pattern_index就可以了。 </p> <p> <span style="color:#0000ff">当发生在j长度失配时，只要把pattern向右移动j-overlay(j)长度就可以了。</span> </p> <p> 如果失配时pattern_index==0，相当于pattern第一个字符就不匹配， <br> 这时就应该把target_index加1，向右移动1位就可以了。 </p> <p> </p> <p>ok，下图就是KMP算法的过程（红色即是采用KMP算法的执行过程）：</p> <p> <img alt="" src="http://hi.csdn.net/attachment/201101/1/8394323_12938727418BHQ.jpg" width="602" height="587"> </p> <p> </p> <p> <span style="font-size:16px">另一作者saturnman发现，在上述KMP匹配过程图中，index=8和index=11处画错了。还有，anaven也早已发现，index=3处也画错了。非常感谢。但图已无法修改，见谅。</span> </p> <p> </p> <p>KMP 算法可在O（n+m）时间内完成全部的串的模式匹配工作。</p> <p> </p> <p>ok，最后给出KMP算法实现的c++代码：</p> <p> #include&lt;iostream&gt; <br> #include&lt;string&gt; <br> #include&lt;vector&gt; <br> using namespace std; </p> <p> int kmp_find(const string&amp; target,const string&amp; pattern) <br> { <br> const int target_length = target.size(); <br> const int pattern_length = pattern.size(); <br> int * overlay_value = new int[pattern_length]; <br> overlay_value[0] = -1; <br> int index = 0; <br> for(int i=1;i&lt;pattern_length;++i) <br> { <br> index = overlay_value[i-1]; <br> while(index&gt;=0 &amp;&amp; pattern[index+1]!=pattern[i]) <br> { <br> index = overlay_value[index]; <br> } <br> if(pattern[index+1]==pattern[i]) <br> { <br> overlay_value[i] = index +1; <br> } <br> else <br> { <br> overlay_value[i] = -1; <br> } <br> } <br> //match algorithm start <br> int pattern_index = 0; <br> int target_index = 0; <br> while(pattern_index&lt;pattern_length&amp;&amp;target_index&lt;target_length) <br> { <br> if(target[target_index]==pattern[pattern_index]) <br> { <br> ++target_index; <br> ++pattern_index; <br> } <br> else if(pattern_index==0) <br> { <br> ++target_index; <br> } <br> else <br> { <br> pattern_index = overlay_value[pattern_index-1]+1; <br> } <br> } <br> if(pattern_index==pattern_length) <br> { <br> return target_index-pattern_index; <br> } <br> else <br> { <br> return -1; <br> } <br> delete [] overlay_value; <br> } </p> <p> int main() <br> { <br> string source = " annbcdanacadsannannabnna"; <br> string pattern = " annacanna"; <br> cout&lt;&lt;kmp_find(source,pattern)&lt;&lt;endl; <br> return 0; <br> } <br> //运行结果为 -1. </p> <p> </p> <p> <span style="font-size:13px"> <span style="color:#800000"> <span style="font-size:16px">第三节、kmp算法的来源</span> </span> <br> </span> kmp如此精巧，那么它是怎么来的呢，为什么要三个人合力才能想出来。其实就算没有kmp算法，人们在字符匹配中也能找到相同高效的算法。这种算法,最终相当于kmp算法，只是这种算法的出发点不是覆盖函数，不是直接从匹配的内在原理出发，而使用此方法的计算的覆盖函数过程序复杂且不易被理解，但是一但找到这个覆盖函数，那以后使用同一pattern匹配时的效率就和kmp一样了，其实这种算法找到的函数不应叫做覆盖函数，因为在寻找过程中根本没有考虑是否覆盖的问题。 </p> <p> 说了这么半天那么这种方法是什么呢，这种方法是就大名鼎鼎的确定的有限自动机(Deterministic finite state automaton DFA),DFA可识别的文法是3型文法，又叫正规文法或是正则文法，既然可以识别正则文法，那么识别确定的字串肯定不是问题(确定字串是正则式的一个子集)。对于如何构造DFA,是有一个完整的算法，这里不做介绍了。在识别确定的字串时使用DFA实在是大材小用，DFA可以识别更加通用的正则表达式，而用通用的构建DFA的方法来识别确定的字串，那这个overhead就显得太大了。</p> <p> kmp算法的可贵之处是从字符匹配的问题本身特点出发，巧妙使用覆盖函数这一表征pattern自身特点的这一概念来快速直接生成识别字串的DFA,因此对于kmp这种算法，理解这种算法高中数学就可以了，但是如果想从无到有设计出这种算法是要求有比较深的数学功底的。</p> <p> </p> <p> <span style="color:#800000"> <span style="font-size:16px"> 第四节、 <span style="font-family:宋体">精确字符匹配的常见算法的解析</span> </span> </span> </p> <blockquote> <p class="MsoNormal" style="text-align:left; margin:0cm 0cm 0pt; padding-left:30px"> <span style="font-size:13px"> <span> <span style="font-family:Calibri; color:red">KMP</span> </span> <span> <span style="font-family:宋体; color:red">算法：</span> </span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black">KMP</span> <span style="font-family:宋体; color:black">就是串匹配算法</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">运用自动机原理</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">比如说</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">我们在</span> <span style="font-family:Arial; color:black">S</span> <span style="font-family:宋体; color:black">中找</span> <span style="font-family:Arial; color:black">P</span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">设</span> <span style="font-family:Arial; color:black">P</span> <span style="font-family:宋体; color:black">＝</span> <span style="font-family:Arial; color:black">{ababbaaba}</span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">我们将</span> <span style="font-family:Arial; color:black">P</span> <span style="font-family:宋体; color:black">对自己匹配</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">下面是求的过程</span> <span style="font-family:Arial; color:black">:{</span> <span style="font-family:宋体; color:black">依次记下匹配失败的那一位</span> <span style="font-family:Arial; color:black">}</span> </span> </p> <span style="font-family:Arial; color:black"> <span style="font-size:13px"></span> </span> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[2]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt"> ....... <span style="text-decoration:underline">a</span> babbaaba[1] </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[3]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt"> ......... <span style="text-decoration:underline">a</span> babbaaba[1] </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[4]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt"> .........a <span style="text-decoration:underline">b</span> abbaaba[2] </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[5]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt"> .........ab <span style="text-decoration:underline">a</span> bbaaba[3] </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[6]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">................ababbaaba[1]</span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[7]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">................ababbaaba[2]</span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[8]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">..................ababbaaba[2]</span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">[9]ababbaaba </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black; font-size:12pt">..................ababbaaba[3]</span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">得到</span> <span style="font-family:Arial; color:black">Next</span> <span style="font-family:宋体; color:black">数组『</span> <span style="font-family:Arial; color:black">0,1,1,2,3,1,2,2,3</span> <span style="font-family:宋体; color:black">』</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">主过程：</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:black"> <span style="font-size:13px">[1]i:=1 j:=1</span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black">[2]</span> <span style="font-family:宋体; color:black">若</span> <span style="font-family:Arial; color:black">(j&gt;m)</span> <span style="font-family:宋体; color:black">或</span> <span style="font-family:Arial; color:black">(i&gt;n)</span> <span style="font-family:宋体; color:black">转</span> <span style="font-family:Arial; color:black">[4]</span> <span style="font-family:宋体; color:black">否则转</span> <span style="font-family:Arial; color:black">[3]</span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black">[3]</span> <span style="font-family:宋体; color:black">若</span> <span style="font-family:Arial; color:black">j=0</span> <span style="font-family:宋体; color:black">或</span> <span style="font-family:Arial; color:black">a[i]=b[j]</span> <span style="font-family:宋体; color:black">则【</span> <span style="font-family:Arial; color:black">inc(i)inc(j)</span> <span style="font-family:宋体; color:black">转</span> <span style="font-family:Arial; color:black">[2]</span> <span style="font-family:宋体; color:black">】否则【</span> <span style="font-family:Arial; color:black">j:=next[j]</span> <span style="font-family:宋体; color:black">转</span> <span style="font-family:Arial; color:black">2</span> <span style="font-family:宋体; color:black">】</span> <span style="font-family:Arial; color:black"></span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black">[4]</span> <span style="font-family:宋体; color:black">若</span> <span style="font-family:Arial; color:black">j&gt;m</span> <span style="font-family:宋体; color:black">则</span> <span style="font-family:Arial; color:black">return(i-m)</span> <span style="font-family:宋体; color:black">否则</span> <span style="font-family:Arial; color:black">return -1; </span> </span> </p> <p class="MsoNormal" align="left" style="text-align:left; line-height:18pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:宋体; color:black">若返回－</span> <span style="font-family:Arial; color:black">1</span> <span style="font-family:宋体; color:black">表示失败，否则表示在</span> <span style="font-family:Arial; color:black">i-m</span> <span style="font-family:宋体; color:black">处成功</span> </span> </p> <p class="MsoNormal" style="margin:0cm 0cm 0pt"> <span> <span style="font-family:Calibri; color:red"> <span style="font-size:13px"> </span> </span> </span> </p> <p class="MsoNormal" style="margin:0cm 0cm 0pt; padding-left:30px"> <span style="font-size:13px"> <span style="font-family:宋体; font-size:13px; color:red">BM</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">算法也是一种快速串匹配算法，</span> </span> <span style="font-family:Arial; color:#333333">KMP</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">算法的主要区别是匹配操作的方向不同。虽然</span> </span> <span style="font-family:Arial; color:#333333">T</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:#333333">右移的计算方法却发生了较大的变化。</span> </span> </span> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">为方便讨论，</span> </span> <span style="font-family:Arial; color:#333333">T</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">＝＂</span> </span> <span style="font-family:宋体; font-size:13px; color:#333333"> dist <span> </span> </span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">：ｃ－＞｛</span> </span> <span style="font-family:宋体; font-size:13px; color:#333333">dist</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">称为滑动距离函数，它给出了正文中可能出现的任意字符在模式中的位置。函数</span> </span> <span style="font-family:宋体; font-size:13px; color:#333333"> <span> </span> <span> </span> m – j <span> </span> j </span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">为</span> </span> <span style="font-family:宋体; color:#333333"> <span> </span> dist </span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">（</span> </span> <span style="font-family:Arial; color:#333333"> m+1 <span> </span> </span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">若</span> </span> <span style="font-family:Arial; color:#333333">c = tm</span> </span> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">例如，</span> </span> <span style="font-family:Arial; color:#333333">pattern</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">＂，则</span> </span> <span style="font-family:Arial; color:#333333">p</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">）</span> </span> <span style="font-family:Arial; color:#333333">a</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">）</span> </span> <span style="font-family:Arial; color:#333333">t</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">）</span> </span> <span style="color:#333333">dist</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">（</span> </span> <span style="font-family:Arial; color:#333333">= 2</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">，</span> </span> <span style="font-family:Arial; color:#333333">r</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">）</span> </span> <span style="font-family:Arial; color:#333333">n</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">）</span> </span> <span style="color:#333333">BM</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">算法的基本思想是：假设将主串中自位置</span> </span> <span style="font-family:Arial; color:#333333">i + dist(si)</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">位置开始重新进行新一轮的匹配，其效果相当于把模式和主串向右滑过一段距离</span> </span> <span style="font-family:Arial; color:#333333">si</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">），即跳过</span> </span> <span style="font-family:Arial; color:#333333">si</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:#333333">）个字符而无需进行比较。</span> </span> </span> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">下面是一个</span> </span> <span style="font-family:Arial; color:#333333">S =</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">＂</span> </span> <span style="font-family:Arial; color:#333333">T=</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">＂</span> </span> <span style="font-family:宋体; font-size:13px; color:#333333">BM</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:#333333">算法可以大大加快串匹配的速度。</span> </span> </span> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">下面是</span> </span> <span style="font-family:Arial; color:#333333">KMP</span> <span style="font-family:Arial; color:#333333"> <span style="font-family:宋体">算法部分，把调用</span> </span> <span style="font-family:Arial; color:#333333">BM</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:#333333">函数便可。</span> </span> </span> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> </p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:red; font-size:10.5pt"> </span></p><div class="dp-highlighter nogutter bg_cpp:nogutter"> <div class="bar"> <div class="tools"> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a> <a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a> </div> </div> <ol start="1" class="dp-cpp"> <li class="alt"> <span> <span class="preprocessor">#include &lt;iostream&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="keyword">using</span> <span> </span> <span class="keyword">namespace</span> <span> std; </span> </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> Dist(</span> <span class="datatypes">char</span> <span> *t,</span> <span class="datatypes">char</span> <span> ch) </span> </span> </li> <li class="alt"> <span>{ </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> len = strlen(t); </span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> i = len - 1; </span> </span> </li> <li class=""> <span> <span class="keyword">if</span> <span>(ch == t[i]) </span> </span> </li> <li class="alt"> <span> <span class="keyword">return</span> <span> len; </span> </span> </li> <li class=""> <span> i--; </span> </li> <li class="alt"> <span> <span class="keyword">while</span> <span>(i &gt;= 0) </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> <span class="keyword">if</span> <span>(ch == t[i]) </span> </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> len - 1 - i; </span> </span> </li> <li class="alt"> <span> <span class="keyword">else</span> <span> </span> </span> </li> <li class=""> <span> i--; </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> len; </span> </span> </li> <li class="alt"> <span>} </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> BM(</span> <span class="datatypes">char</span> <span> *s,</span> <span class="datatypes">char</span> <span> *t) </span> </span> </li> <li class=""> <span>{ </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> n = strlen(s); </span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> m = strlen(t); </span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> i = m-1; </span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> j = m-1; </span> </span> </li> <li class="alt"> <span> <span class="keyword">while</span> <span>(j&gt;=0 &amp;&amp; i&lt;n) </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> <span class="keyword">if</span> <span>(s[i] == t[j]) </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> i--; </span> </li> <li class=""> <span> j--; </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> <span class="keyword">else</span> <span> </span> </span> </li> <li class="alt"> <span> { </span> </li> <li class=""> <span> i += Dist(t,s[i]); </span> </li> <li class="alt"> <span> j = m-1; </span> </li> <li class=""> <span> } </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> <span class="keyword">if</span> <span>(j &lt; 0) </span> </span> </li> <li class="alt"> <span> { </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> i+1; </span> </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> -1; </span> </span> </li> <li class="alt"> <span>} </span> </li> </ol> </div> <textarea class="cpp:nogutter" rows="15" cols="50" name="code" style="display: none">#include &lt;iostream&gt; using namespace std; int Dist(char *t,char ch) { int len = strlen(t); int i = len - 1; if(ch == t[i]) return len; i--; while(i &gt;= 0) { if(ch == t[i]) return len - 1 - i; else i--; } return len; } int BM(char *s,char *t) { int n = strlen(s); int m = strlen(t); int i = m-1; int j = m-1; while(j&gt;=0 &amp;&amp; i&lt;n) { if(s[i] == t[j]) { i--; j--; } else { i += Dist(t,s[i]); j = m-1; } } if(j &lt; 0) { return i+1; } return -1; }</textarea> <span style="font-size:13px"> </span> <p></p> <p style="line-height:16.5pt; text-indent:21.75pt; margin:0cm 0cm 0pt"> <span style="font-family:Arial; color:red"> <span style="font-size:13px"> </span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:red">Horspool</span> <span style="font-family:Arial; color:red"> <span style="font-family:宋体">算法</span> </span> </span> <span style="font-family:Arial; color:black; font-size:10.5pt"> <br> </span> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">这个算法是由</span> </span> <span style="font-family:Arial; color:black">R.Nigel Horspool</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">在</span> </span> <span style="font-family:Arial; color:black">1980</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">年提出的。其滑动思想非常简单，就是从后往前匹配模式串，若在某一位失去匹配，此位对应的文本串字符为</span> </span> <span style="font-family:Arial; color:black">c</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">，那就将模式串向右滑动，使模式</span> </span> </span> <span style="font-family:Arial; color:black; font-size:10.5pt"> <br> </span> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">串之前最近的</span> </span> <span style="font-family:Arial; color:black">c</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">对准这一位，再从新从后往前检查。那如果之前找不到</span> </span> <span style="font-family:Arial; color:black">c</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">怎么办？那好极了，直接将整个模式串滑过这一位。</span> </span> </span> <span style="font-family:Arial; color:black; font-size:10.5pt"> <br> </span> <span style="font-family:宋体"> <span style="font-family:Arial; color:black"> <span style="font-size:13px">例如：</span> </span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-family:Arial; color:black; font-size:10.5pt"> <span style="font-family:宋体"> <span style="font-size:13px">文本串：</span> </span> </span> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> abdabaca <br> </span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">模式串：</span> </span> <span style="font-family:Arial; color:black">baca</span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">倒数第</span> </span> <span style="font-family:Arial; color:black">2</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">位失去匹配，模式串之前又没有</span> </span> <span style="font-family:Arial; color:black">d</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:black">，那模式串就可以整个滑过，变成这样：</span> </span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-family:Arial; color:black; font-size:10.5pt"> <span style="font-family:宋体"> <span style="font-size:13px">文本串：</span> </span> </span> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> abdabaca <br> </span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">模式串：</span> </span> <span style="font-family:Arial; color:black"> baca</span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">发现倒数第</span> </span> <span style="font-family:Arial; color:black">1</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">位就失去匹配，之前</span> </span> <span style="font-family:Arial; color:black">1</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">位有</span> </span> <span style="font-family:Arial; color:black">c</span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">，那就向右滑动</span> </span> <span style="font-family:Arial; color:black">1</span> <span style="font-family:宋体"> <span style="font-family:Arial; color:black">位：</span> </span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-family:Arial; color:black; font-size:10.5pt"> <span style="font-family:宋体"> <span style="font-size:13px">文本串：</span> </span> </span> <span style="font-size:13px"> <span style="font-family:Arial; color:black"> abdabaca <br> </span> <span style="font-family:Arial; color:black"> <span style="font-family:宋体">模式串：</span> </span> <span style="font-family:Arial; color:black"> baca</span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-family:宋体"> <span style="font-family:Arial; color:black"> <span style="font-size:13px">实现代码：</span> </span> </span> </p> <p style="line-height:16.5pt; margin:0cm 0cm 7.5pt"> <span style="font-family:Arial; color:black; font-size:10.5pt"> </span></p><div class="dp-highlighter nogutter bg_cpp:nogutter"> <div class="bar"> <div class="tools"> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a> <a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a> </div> </div> <ol start="1" class="dp-cpp"> <li class="alt"> <span> <span class="preprocessor">#include &lt;iostream&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="preprocessor">#include &lt;vector&gt;</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="preprocessor">#include &lt;string&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="preprocessor">#include &lt;cstdlib&gt;</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="keyword">using</span> <span> </span> <span class="keyword">namespace</span> <span> std; </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> Horspool_match(</span> <span class="keyword">const</span> <span> string &amp; S,</span> <span class="keyword">const</span> <span> string &amp; M,</span> <span class="datatypes">int</span> <span> pos) </span> </span> </li> <li class=""> <span>{ </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> S_len = S.size(); </span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> M_len = M.size(); </span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> Mi = M_len-1,Si= pos+Mi; </span> <span class="comment">//这里的串的第1个元素下标是0</span> <span> </span> </span> </li> <li class=""> <span> <span class="keyword">if</span> <span>( (S_len-pos) &lt; M_len ) </span> </span> </li> <li class="alt"> <span> <span class="keyword">return</span> <span> -1; </span> </span> </li> <li class=""> <span> <span class="keyword">while</span> <span> ( (Mi&gt;-1) &amp;&amp; (Si&lt;S_len) ) </span> </span> </li> <li class="alt"> <span> { </span> </li> <li class=""> <span> <span class="keyword">if</span> <span> (S[Si] == M[Mi]) </span> </span> </li> <li class="alt"> <span> { </span> </li> <li class=""> <span> --Mi; </span> </li> <li class="alt"> <span> --Si; </span> </li> <li class=""> <span> } </span> </li> <li class="alt"> <span> <span class="keyword">else</span> <span> </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> <span class="keyword">do</span> <span> </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> Mi--; </span> </li> <li class=""> <span> } </span> </li> <li class="alt"> <span> <span class="keyword">while</span> <span>( (S[Si]!=M[Mi]) || (Mi&gt;-1) ); </span> </span> </li> <li class=""> <span> Mi = M_len - 1; </span> </li> <li class="alt"> <span> Si += M_len - 1; </span> </li> <li class=""> <span> } </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> <span class="keyword">if</span> <span>(Si &lt; S_len) </span> </span> </li> <li class="alt"> <span> <span class="keyword">return</span> <span>(Si + 1); </span> </span> </li> <li class=""> <span> <span class="keyword">else</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="keyword">return</span> <span> -1; </span> </span> </li> <li class=""> <span>} </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> main( ) </span> </span> </li> <li class="alt"> <span>{ </span> </li> <li class=""> <span> string S= <span class="string">"abcdefghabcdefghhiijiklmabc"</span> <span>; </span> </span> </li> <li class="alt"> <span> string T= <span class="string">"hhiij"</span> <span>; </span> </span> </li> <li class=""> <span> <span class="datatypes">int</span> <span> pos = Horspool_match(S,T,3); </span> </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> cout&lt;&lt; <span class="string">"/n"</span> <span>&lt;&lt;pos&lt;&lt;endl; </span> </span> </li> <li class="alt"> <span> system( <span class="string">"pause"</span> <span>); </span> </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> 0; </span> </span> </li> <li class="alt"> <span>} </span> </li> </ol> </div> <textarea class="cpp:nogutter" rows="15" cols="50" name="code" style="display: none">#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; using namespace std; int Horspool_match(const string &amp; S,const string &amp; M,int pos) { int S_len = S.size(); int M_len = M.size(); int Mi = M_len-1,Si= pos+Mi; //这里的串的第1个元素下标是0 if( (S_len-pos) &lt; M_len ) return -1; while ( (Mi&gt;-1) &amp;&amp; (Si&lt;S_len) ) { if (S[Si] == M[Mi]) { --Mi; --Si; } else { do { Mi--; } while( (S[Si]!=M[Mi]) || (Mi&gt;-1) ); Mi = M_len - 1; Si += M_len - 1; } } if(Si &lt; S_len) return(Si + 1); else return -1; } int main( ) { string S="abcdefghabcdefghhiijiklmabc"; string T="hhiij"; int pos = Horspool_match(S,T,3); cout&lt;&lt;"/n"&lt;&lt;pos&lt;&lt;endl; system("pause"); return 0; }</textarea> <span style="font-size:13px"> </span> <span> <span style="font-family:Calibri; color:red"> <span style="font-size:13px"> </span> </span> </span> <p></p> <p class="MsoNormal" style="margin:0cm 0cm 0pt"> <span style="font-size:13px"> <span> <span style="font-family:Calibri; color:red">SUNDAY</span> </span> <span> <span style="font-family:宋体; color:red">算法：</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <span> <span style="font-family:Calibri"> <span style="font-size:13px">BM</span> </span> </span> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">算法的改进的算法</span> </span> <span> <span style="font-family:Calibri; color:black">SUNDAY--Boyer-Moore-Horspool-Sunday Aglorithm</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <br> <span> <span style="font-family:Calibri"> <span style="font-size:13px">BM</span> </span> </span> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">算法优于</span> </span> <span> <span style="font-family:Calibri; color:black">KMP</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <br> <span> <span style="font-family:Calibri"> <span style="font-size:13px">SUNDAY </span> </span> </span> </span> <span> <span style="font-family:宋体; color:black"> <span style="font-size:13px">算法描述：</span> </span> </span> <span style="color:black"> <br> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">字符串查找算法中，最著名的两个是</span> </span> <span> <span style="font-family:Calibri; color:black">KMP</span> </span> <span> <span style="font-family:宋体; color:black">算法（</span> </span> <span> <span style="font-family:Calibri; color:black">Knuth-Morris-Pratt)</span> </span> <span> <span style="font-family:宋体; color:black">和</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法（</span> </span> <span> <span style="font-family:Calibri; color:black">Boyer-Moore)</span> </span> <span> <span style="font-family:宋体; color:black">。两个算法在最坏情况下均具有线性的查找时间。但是在实用上，</span> </span> <span> <span style="font-family:Calibri; color:black">KMP</span> </span> <span> <span style="font-family:宋体; color:black">算法并不比最简单的</span> </span> <span> <span style="font-family:Calibri; color:black">c</span> </span> <span> <span style="font-family:宋体; color:black">库函数</span> </span> <span> <span style="font-family:Calibri; color:black">strstr()</span> </span> <span> <span style="font-family:宋体; color:black">快多少，而</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法则往往比</span> </span> <span> <span style="font-family:Calibri; color:black">KMP</span> </span> <span> <span style="font-family:宋体; color:black">算法快上</span> </span> <span> <span style="font-family:Calibri; color:black">3</span> </span> <span> <span style="font-family:宋体; color:black">－</span> </span> <span> <span style="font-family:Calibri; color:black">5</span> </span> <span> <span style="font-family:宋体; color:black">倍。但是</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法还不是最快的算法，这里介绍一种比</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法更快一些的查找算法即</span> </span> <span> <span style="font-family:Calibri; color:black">Sunday</span> </span> <span> <span style="font-family:宋体; color:black">算法。</span> </span> </span> <span style="color:black"> <br> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">例如我们要在</span> </span> <span> <span style="font-family:Calibri; color:black">"substring searching algorithm"</span> </span> <span> <span style="font-family:宋体; color:black">查找</span> </span> <span> <span style="font-family:Calibri; color:black">"search"</span> </span> <span> <span style="font-family:宋体; color:black">，刚开始时，把子串与文本左边对齐：</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <br> <span style="font-size:13px"> <span> <span style="font-family:Calibri">substring searching algorithm</span> </span> <br> <span> <span style="font-family:Calibri">search</span> </span> <br> <span> <span style="font-family:Calibri">^</span> </span> <br> </span> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">结果在第二个字符处发现不匹配，于是要把子串往后移动。但是该移动多少呢？这就是各种算法各显神通的地方了，最简单的做法是移动一个字符位置；</span> </span> <span> <span style="font-family:Calibri; color:red">KMP</span> </span> <span> <span style="font-family:宋体; color:red">是利用已经匹配部分的信息来移动；</span> </span> <span> <span style="font-family:Calibri; color:red">BM</span> </span> <span> <span style="font-family:宋体; color:red">算法是做反向比较，并根据已经匹配的部分来确定移动量。</span> </span> <span> <span style="font-family:宋体; color:black">这里要介绍的方法是看紧跟在当前子串之后的那个字符（上图中的</span> </span> <span> <span style="font-family:Calibri; color:black"> 'i')</span> </span> <span> <span style="font-family:宋体; color:black">。</span> </span> </span> <span style="color:black"> <br> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">显然，不管移动多少，这个字符是肯定要参加下一步的比较的，也就是说，如果下一步匹配到了，这个字符必须在子串内。所以，可以移动子串，使子串中的最右边的这个字符与它对齐。现在子串</span> </span> <span> <span style="font-family:Calibri; color:black">'search'</span> </span> <span> <span style="font-family:宋体; color:black">中并不存在</span> </span> <span> <span style="font-family:Calibri; color:black">'i'</span> </span> <span> <span style="font-family:宋体; color:black">，则说明可以直接跳过一大片，从</span> </span> <span> <span style="font-family:Calibri; color:black">'i'</span> </span> <span> <span style="font-family:宋体; color:black">之后的那个字符开始作下一步的比较，如下图：</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <br> <span style="font-size:13px"> <span> <span style="font-family:Calibri">substring searching algorithm</span> </span> <br> </span> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black"> </span> </span> <span> <span style="font-family:Calibri; color:black"> search</span> </span> </span> <span style="color:black"> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black"> </span> </span> <span> <span style="font-family:Calibri; color:black">^</span> </span> </span> <span style="color:black"> <br> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">比较的结果，第一个字符就不匹配，再看子串后面的那个字符，是</span> </span> <span> <span style="font-family:Calibri; color:black">'r',</span> </span> <span> <span style="font-family:宋体; color:black">它在子串中出现在倒数第三位，于是把子串向前移动三位，使两个</span> </span> <span> <span style="font-family:Calibri; color:black">'r'</span> </span> <span> <span style="font-family:宋体; color:black">对齐，如下：</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <br> <span style="font-size:13px"> <span> <span style="font-family:Calibri">substring searching algorithm</span> </span> <br> </span> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black"> </span> </span> <span> <span style="font-family:Calibri; color:black"> search</span> </span> </span> <span style="color:black"> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black"> </span> </span> <span> <span style="font-family:Calibri; color:black">^</span> </span> </span> <span style="color:black"> <br> <br> </span> <span style="font-size:13px"> <span> <span style="font-family:宋体; color:black">哈！这次匹配成功了！回顾整个过程，我们只移动了两次子串就找到了匹配位置，可以证明，用这个算法，每一步的移动量都比</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法要大，所以肯定比</span> </span> <span> <span style="font-family:Calibri; color:black">BM</span> </span> <span> <span style="font-family:宋体; color:black">算法更快。</span> </span> </span> <span lang="EN-US" style="color:black"> <br> <span style="font-size:13px"> <span> <span style="font-family:Calibri"> </span></span></span></span></p><div class="dp-highlighter nogutter bg_cpp:nogutter"> <div class="bar"> <div class="tools"> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a> <a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a> </div> </div> <ol start="1" class="dp-cpp"> <li class="alt"> <span> <span class="preprocessor">#include&lt;iostream&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="preprocessor">#include&lt;fstream&gt;</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="preprocessor">#include&lt;vector&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="preprocessor">#include&lt;algorithm&gt;</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="preprocessor">#include&lt;string&gt;</span> <span> </span> </span> </li> <li class=""> <span> <span class="preprocessor">#include&lt;list&gt;</span> <span> </span> </span> </li> <li class="alt"> <span> <span class="preprocessor">#include&lt;functional&gt;</span> <span> </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="keyword">using</span> <span> </span> <span class="keyword">namespace</span> <span> std; </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="datatypes">int</span> <span> main() </span> </span> </li> <li class=""> <span>{ </span> </li> <li class="alt"> <span> <span class="datatypes">char</span> <span> *text=</span> <span class="keyword">new</span> <span> </span> <span class="datatypes">char</span> <span>[100]; </span> </span> </li> <li class=""> <span> text= <span class="string">"substring searching algorithm search"</span> <span>; </span> </span> </li> <li class="alt"> <span> <span class="datatypes">char</span> <span> *patt=</span> <span class="keyword">new</span> <span> </span> <span class="datatypes">char</span> <span>[10]; </span> </span> </li> <li class=""> <span> patt= <span class="string">"search"</span> <span>; </span> </span> </li> <li class="alt"> <span> <span class="datatypes">size_t</span> <span> temp[256]; </span> </span> </li> <li class=""> <span> <span class="datatypes">size_t</span> <span> *shift=temp; </span> </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> <span class="datatypes">size_t</span> <span> patt_size=strlen(patt); </span> </span> </li> <li class="alt"> <span> cout&lt;&lt; <span class="string">"size : "</span> <span>&lt;&lt;patt_size&lt;&lt;endl; </span> </span> </li> <li class=""> <span> <span class="keyword">for</span> <span>(</span> <span class="datatypes">size_t</span> <span> i=0;i&lt;256;i++) </span> </span> </li> <li class="alt"> <span> *(shift+i)=patt_size+1; <span class="comment">//所有值赋于7，对这题而言</span> <span> </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="keyword">for</span> <span>(i=0;i&lt;patt_size;i++) </span> </span> </li> <li class=""> <span> *(shift+unsigned <span class="datatypes">char</span> <span>(*(patt+i) ) )=patt_size-i; </span> </span> </li> <li class="alt"> <span> <span class="comment">/* // 移动3步--&gt;shift['r']=6-3=3;移动三步</span> </span> </li> <li class=""> <span> <span class="comment"> //shift['s']=6步,shitf['e']=5以此类推</span> </span> </li> <li class="alt"> <span> <span class="comment"> */</span> <span> </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="datatypes">size_t</span> <span> text_size=strlen(text); </span> </span> </li> <li class=""> <span> <span class="datatypes">size_t</span> <span> limit=text_size-i+1; </span> </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> <span class="keyword">for</span> <span>(i=0;i&lt;limit;i+=shift[text[i+patt_size] ] ) </span> </span> </li> <li class="alt"> <span> <span class="keyword">if</span> <span>(text[i]==*patt) </span> </span> </li> <li class=""> <span> { </span> </li> <li class="alt"> <span> <span class="comment">/* ^13--这个r是位，从0开始算</span> </span> </li> <li class=""> <span> <span class="comment"> substring searching algorithm</span> </span> </li> <li class="alt"> <span> <span class="comment"> search</span> </span> </li> <li class=""> <span> <span class="comment"> searching--&gt;这个s为第10位，从0开始算</span> </span> </li> <li class="alt"> <span> <span class="comment"> 如果第一个字节匹配，那么继续匹配剩下的</span> </span> </li> <li class=""> <span> <span class="comment"> */</span> <span> </span> </span> </li> <li class="alt"> <span> </span> </li> <li class=""> <span> <span class="datatypes">char</span> <span>* match_text=text+i+1; </span> </span> </li> <li class="alt"> <span> <span class="datatypes">size_t</span> <span> match_size=1; </span> </span> </li> <li class=""> <span> <span class="keyword">do</span> <span>{ </span> </span> </li> <li class="alt"> <span> <span class="keyword">if</span> <span>(match_size==patt_size) </span> </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> cout&lt;&lt; <span class="string">"the no is "</span> <span>&lt;&lt;i&lt;&lt;endl; </span> </span> </li> <li class=""> <span> } <span class="keyword">while</span> <span>( (*match_text++)==patt[match_size++] ); </span> </span> </li> <li class="alt"> <span> } </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> cout&lt;&lt;endl; </span> </li> <li class=""> <span> <span class="keyword">return</span> <span> 0; </span> </span> </li> <li class="alt"> <span>} </span> </li> <li class=""> <span> </span> </li> <li class="alt"> <span> <span class="comment">//运行结果如下：</span> <span> </span> </span> </li> <li class=""> <span> <span class="comment">/*</span> </span> </li> <li class="alt"> <span> <span class="comment">size : 6</span> </span> </li> <li class=""> <span> <span class="comment">the no is 10</span> </span> </li> <li class="alt"> <span> <span class="comment">the no is 30</span> </span> </li> <li class=""> <span> <span class="comment">Press any key to continue</span> </span> </li> <li class="alt"> <span> <span class="comment">*/</span> <span> </span> </span> </li> </ol> </div> <textarea class="cpp:nogutter" rows="15" cols="50" name="code" style="display: none">#include&lt;iostream&gt; #include&lt;fstream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;string&gt; #include&lt;list&gt; #include&lt;functional&gt; using namespace std; int main() { char *text=new char[100]; text="substring searching algorithm search"; char *patt=new char[10]; patt="search"; size_t temp[256]; size_t *shift=temp; size_t patt_size=strlen(patt); cout&lt;&lt;"size : "&lt;&lt;patt_size&lt;&lt;endl; for(size_t i=0;i&lt;256;i++) *(shift+i)=patt_size+1;//所有值赋于7，对这题而言 for(i=0;i&lt;patt_size;i++) *(shift+unsigned char(*(patt+i) ) )=patt_size-i; /* // 移动3步--&gt;shift['r']=6-3=3;移动三步 //shift['s']=6步,shitf['e']=5以此类推 */ size_t text_size=strlen(text); size_t limit=text_size-i+1; for(i=0;i&lt;limit;i+=shift[text[i+patt_size] ] ) if(text[i]==*patt) { /* ^13--这个r是位，从0开始算 substring searching algorithm search searching--&gt;这个s为第10位，从0开始算 如果第一个字节匹配，那么继续匹配剩下的 */ char* match_text=text+i+1; size_t match_size=1; do{ if(match_size==patt_size) cout&lt;&lt;"the no is "&lt;&lt;i&lt;&lt;endl; }while( (*match_text++)==patt[match_size++] ); } cout&lt;&lt;endl; return 0; } //运行结果如下： /* size : 6 the no is 10 the no is 30 Press any key to continue */ </textarea> <span style="font-size:13px"> </span> <p></p> </blockquote> <p> 本文完，更多请参考： <span style="font-size:18px;"> <a href="http://blog.csdn.net/v_JULY_v/archive/2011/06/15/6545192.aspx" target="_blank"> <strong>六（续）、从KMP算法一步一步谈到BM算法</strong> </a> 。 </span> </p> </div> 引用： http://blog.csdn.net/v_JULY_v/article/details/6111565<div>参考：http://plussai.iteye.com/blog/1162741</div><div><br></div>
    </td>
  </tr>
  <tr>
    <td>
      <br /><br />
      原文： <a href='http://nullget.sourceforge.net/?q=node/623'>http://nullget.sourceforge.net/?q=node/623</a>
    </td>
  </tr>

</table>

<p></p>
<p></p>
<p></p>
<table width="60%"><tr><td  align="center">
  <div>
    <span>Powered by <a href="http://nullget.sourceforge.net">zexport</a></span>  </div>
  </div>
  </td></tr></table>

<br />
<div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51467019-1', 'qtchina.github.io');
  ga('send', 'pageview');

</script>

</div>
</body>
</html>
