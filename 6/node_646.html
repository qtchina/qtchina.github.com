
<!DOCTYPE HTML>
<html>
<head>
<meta charset='utf8'>
<title>PHP内核代码中smart_str更高效的用法</title>
</head>
<body>
在PHP内核中，smart_str默认初始化大小为78，

每次分配多加128字节。

随着以后逐渐append操作执行，

smart_ptr不断检测是否内存已经用完，

如果已经用完则需要重新分配内存，

这样对于存储大字符串的时候，

smart_ptr需要多次检测并分配内存，效率就降低了。

先来看一下smart_str的结构：

typedef struct 

{

char *c;

size_t len;

 size_t a;

}smart_str;

 

其中c成员是字符红缓存，len表示当前已用长度，a表示总长度。

smart_str提供了一个重新分配内存的宏，smart_str_alloc(dest, nlen, what)

为了申请一块大内存，使用如下代码：

int newlen = 5000;

smart_str_alloc(buf, newlen, 0);

第一个代表已有smart_str结构实例指针，

what表示是否分配永久内存，一般用0，表示使用php已经申请使用的内存。

printf("clen=%d, tlen=%d\n", buf->len, buf->a);

可输出当前smart_str的使用情况。



更高效的使用方式来了，

eg1,

buf->c[buf->len++] = '*';    // 追加一个字符。



eg2,

strcpy(buf->c + buf->len, s);

buf->len += strlen(s);       // 追加一个字符串

这样比使用smart_str_appendc宏更有效率。

不过这样的安全问题要注意，前提是已经为后续操作分配了内存的内存，不能内存溢出了。
</body>
</html>
