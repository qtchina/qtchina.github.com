<html>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<head>
<title>Writing TCP ClientServer Applications</title>
<link rel="STYLESHEET" type="text/css" href="images/style.css">
<link rel="STYLESHEET" type="text/css" href="images/docsafari.css">
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<br><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a name="ch14lev1sec3"></a>
<h3 id="570594-824" class="docSection1Title">Writing TCP ClientServer Applications</h3>
<p class="docText">The <tt>QTcpSocket</tt> and <tt>QTcpServer</tt> classes can be used to implement TCP clients and servers. TCP is a transport protocol that forms the basis of most application-level Internet protocols, including FTP and HTTP, and that can also be used for custom protocols.</p>
<p class="docText">TCP is a stream-oriented protocol. For applications, the data appears to be a long stream, rather like a large flat file. The high-level protocols built on top of TCP are typically either line-oriented or block-oriented:</p>
<ul><li><p class="docList">Line-oriented protocols transfer data as lines of text, each terminated by a newline.</p></li><li><p class="docList">Block-oriented protocols transfer data as binary data blocks. Each block consists of a size field followed by that much data.</p></li></ul>
<p class="docText"><tt>QTcpSocket</tt> inherits from <tt>QIODevice</tt> tHRough <tt>QAbstractSocket</tt>, so it can be read from and written to using a <tt>QDataStream</tt> or a <tt>QTextStream</tt>. One notable difference when reading data from a network compared with reading from a file is that we must make sure that we have received enough data from the peer before we use the <tt>&gt;&gt;</tt> operator. Failing to do so may result in undefined behavior.</p>
<p class="docText">In this section, we will review the code of a client and a server that use a custom block-oriented protocol. The client is called Trip Planner and allows users to plan their next train trip. The server is called Trip Server and provides the trip information to the client. We will start by writing the Trip Planner client.</p>
<p class="docText">The Trip Planner provides a From field, a To field, a Date field, an Approximate Time field, and two radio buttons to select whether the approximate time is that of departure or arrival. When the user clicks Search, the application sends a request to the server, which responds with a list of train trips that match the user's criteria. The list is shown in a <tt>QTableWidget</tt> in the Trip Planner window. The very bottom of the window is occupied by a <tt>QLabel</tt> that shows the status of the last operation and a <tt>QProgressBar</tt>.</p>

<p class="docText"></P><a name="ch14fig01"></a><p><center>

<H5 class="docFigureTitle">Figure 14.1. The Trip Planner application</H5>
<p class="docText"><div class="v1"><a target="_self" href="images/tripplanner_alt.jpg">[View full size image]</a></div><img border="0" alt="" id="195131084199" width="500" height="343" SRC="images/tripplanner.jpg"></p>
</center></P><br>
<p class="docText"><a name="iddle6655"></a><a name="iddle6953"></a><a name="iddle6954"></a><a name="iddle6955"></a><a name="iddle6992"></a><a name="iddle6996"></a><a name="iddle7002"></a><a name="iddle7068"></a>The Trip Planner's user interface was created using <span class="docEmphasis">Qt Designer</span> in a file called <tt>tripplanner.ui</tt>. Here, we will focus on the source code of the <tt>QDialog</tt> subclass that implements the application's functionality:</P>
<div class="docText"><pre>
#include "ui_tripplanner.h"
class TripPlanner : public QDialog, public Ui::TripPlanner
{
    Q_OBJECT
public:
    TripPlanner(QWidget *parent = 0);
private slots:
    void connectToServer();
    void sendRequest();
    void updateTableWidget();
    void stopSearch();
    void connectionClosedByServer();
    void error();
private:
    void closeConnection();
    QTcpSocket tcpSocket;
    quint16 nextBlockSize;
};
</pre></div><BR>
<p class="docText">The <tt>TRipPlanner</tt> class inherits from <tt>Ui::TripPlanner</tt> (which is generated by <tt>uic</tt> from <tt>tripplanner.ui</tt>) in addition to <tt>QDialog</tt>. The <tt>tcpSocket</tt> member variable encapsulates the TCP connection. The <tt>nextBlockSize</tt> variable is used when parsing the blocks received from the server.</p>
<div class="docText"><pre>
TripPlanner::TripPlanner(QWidget *parent)
    : QDialog(parent)
{
    setupUi(this);
    QDateTime dateTime = QDateTime::currentDateTime();
    dateEdit-&gt;setDate(dateTime.date());
    timeEdit-&gt;setTime(QTime(dateTime.time().hour(), 0));
    progressBar-&gt;hide();
    progressBar-&gt;setSizePolicy(QSizePolicy::Preferred,
                               QSizePolicy::Ignored);
    tableWidget-&gt;verticalHeader()-&gt;hide();
    tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);
    connect(searchButton, SIGNAL(clicked()),
            this, SLOT(connectToServer()));
    connect(stopButton, SIGNAL(clicked()), this, SLOT(stopSearch()));
    connect(&amp;tcpSocket, SIGNAL(connected()), this, SLOT(sendRequest()));
    connect(&amp;tcpSocket, SIGNAL(disconnected()),
            this, SLOT(connectionClosedByServer()));
    connect(&amp;tcpSocket, SIGNAL(readyRead()),
            this, SLOT(updateTableWidget()));
    connect(&amp;tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)),
            this, SLOT(error()));
}
</pre></div><br>
<p class="docText"><a name="iddle1216"></a><a name="iddle1315"></a><a name="iddle1586"></a><a name="iddle1587"></a><a name="iddle1591"></a><a name="iddle1592"></a><a name="iddle1955"></a><a name="iddle2175"></a><a name="iddle2176"></a><a name="iddle2678"></a><a name="iddle2681"></a><a name="iddle2887"></a><a name="iddle3135"></a><a name="iddle3279"></a><a name="iddle3344"></a><a name="iddle3869"></a><a name="iddle4368"></a><a name="iddle4763"></a><a name="iddle4764"></a><a name="iddle4765"></a><a name="iddle5235"></a><a name="iddle5236"></a><a name="iddle5237"></a><a name="iddle5241"></a><a name="iddle5245"></a><a name="iddle5509"></a><a name="iddle5718"></a><a name="iddle6957"></a><a name="iddle7228"></a>In the constructor, we initialize the date and time editors based on the current date and time. We also hide the progress bar, because we only want to show it when a connection is active. In <span class="docEmphasis">Qt Designer</span>, the progress bar's <tt>minimum</tt> and <tt>maximum</tt> properties were both set to 0. This tells the <tt>QProgressBar</tt> to behave as a busy indicator instead of as a standard percentage-based progress bar.</P>
<p class="docText">Also in the constructor, we connect the <tt>QTcpSocket</tt>'s <tt>connected()</tt>, <tt>disconnected()</tt>, <tt>readyRead()</tt>, and <tt>error(QAbstractSocket::SocketError)</tt> signals to private slots.</p>
<div class="docText"><pre>
void TripPlanner::connectToServer()
{
    tcpSocket.connectToHost("tripserver.zugbahn.de", 6178);
    tableWidget-&gt;setRowCount(0);
    searchButton-&gt;setEnabled(false);
    stopButton-&gt;setEnabled(true);
    statusLabel-&gt;setText(tr("Connecting to server..."));
    progressBar-&gt;show();
    nextBlockSize = 0;
}
</pre></div><br>
<p class="docText">The <tt>connectToServer()</tt> slot is executed when the user clicks Search to start a search. We call <tt>connectToHost()</tt> on the <tt>QTcpSocket</tt> object to connect to the server, which we assume is accessible at port 6178 on the fictitious host <tt>TRipserver.zugbahn.de</tt>. (If you want to try the example on your own machine, replace the host name with <tt>QHostAddress::LocalHost</tt>.) The <tt>connectToHost()</tt> call is asynchronous; it always returns immediately. The connection is typically established later. The <tt>QTcpSocket</tt> object emits the <tt>connected()</tt> signal when the connection is up and running, or <tt>error(QAbstractSocket::SocketError)</tt> if the connection failed.</P>
<p class="docText"><a name="iddle4099"></a><a name="iddle4150"></a><a name="iddle4430"></a><a name="iddle5961"></a><a name="iddle5985"></a><a name="iddle6960"></a>Next, we update the user interface, in particular making the progress bar visible.</p>
<p class="docText">Finally, we set the <tt>nextBlockSize</tt> variable to 0. This variable stores the length of the next block received from the server. We have chosen to use the value of 0 to mean that we don't yet know the size of the next block.</p>
<div class="docText"><pre>
void TripPlanner::sendRequest()
{
    QByteArray block;
    QDataStream out(&amp;block, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_4_1);
    out &lt;&lt; quint16(0) &lt;&lt; quint8('S') &lt;&lt; fromComboBox-&gt;currentText()
        &lt;&lt; toComboBox-&gt;currentText() &lt;&lt; dateEdit-&gt;date()
        &lt;&lt; timeEdit-&gt;time();
    if (departureRadioButton-&gt;isChecked()) {
        out &lt;&lt; quint8('D');
    } else {
        out &lt;&lt; quint8('A');
    }
    out.device()-&gt;seek(0);
    out &lt;&lt; quint16(block.size() - sizeof(quint16));
    tcpSocket.write(block);
    statusLabel-&gt;setText(tr("Sending request..."));
}
</pre></div><br>
<p class="docText">The <tt>sendRequest()</tt> slot is executed when the <tt>QTcpSocket</tt> object emits the <tt>connected()</tt> signal, indicating that a connection has been established. The slot's task is to generate a request to the server, with all the information entered by the user.</p>
<p class="docText">The request is a binary block with the following format:</P>
<p><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><colgroup align="left" span="2"><col width="75"><col width="200"></colgroup><thead></thead><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint16</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Block size in bytes (excluding this field)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint8</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Request type (always 'S')</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>QString</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Departure city</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>QString</tt></P></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Arrival city</p></td></TR><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>QDate</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Date of travel</P></td></tr><TR><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>QTime</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Approximate time of travel</p></TD></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint8</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Time is for departure ('D') or arrival ('A')</p></td></tr></table></p><br>
<p class="docText">We first write the data to a <tt>QByteArray</tt> called <tt>block</tt>. We can't write the data directly to the <tt>QTcpSocket</tt> because we don't know the size of the block, which must be sent first, until after we have put all the data into the block.</p>
<p class="docText">We initially write 0 as the block size, followed by the rest of the data. Then we call <tt>seek(0)</tt> on the I/O device (a <tt>QBuffer</tt> created by <tt>QDataStream</tt> behind the scenes) to move back to the beginning of the byte array, and overwrite the initial 0 with the size of the block's data. The size is calculated by taking the <a name="iddle5246"></a><a name="iddle5252"></a><a name="iddle5719"></a><a name="iddle6962"></a><a name="iddle7051"></a><a name="iddle7313"></a>block's size and subtracting <tt>sizeof(quint16)</tt> (that is, 2) to exclude the size field from the byte count. After that, we call <tt>write()</tt> on the <tt>QTcpSocket</tt> to send the block to the server.</p>
<div class="docText"><pre>
void TripPlanner::updateTableWidget()
{
    QDataStream in(&amp;tcpSocket);
    in.setVersion(QDataStream::Qt_4_1);
    forever {
        int row = tableWidget-&gt;rowCount();
        if (nextBlockSize == 0) {
            if (tcpSocket.bytesAvailable() &lt; sizeof(quint16))
                break;
            in &gt;&gt; nextBlockSize;
        }
        if (nextBlockSize == 0xFFFF) {
            closeConnection();
            statusLabel-&gt;setText(tr("Found %1 trip(s)").arg(row));
            break;
        }
        if (tcpSocket.bytesAvailable() &lt; nextBlockSize)
            break;
        QDate date;
        QTime departureTime;
        QTime arrivalTime;
        quint16 duration;
        quint8 changes;
        QString trainType;
        in &gt;&gt; date &gt;&gt; departureTime &gt;&gt; duration &gt;&gt; changes &gt;&gt; trainType;
        arrivalTime = departureTime.addSecs(duration * 60);
        tableWidget-&gt;setRowCount(row + 1);
        QStringList fields;
        fields &lt;&lt; date.toString(Qt::LocalDate)
               &lt;&lt; departureTime.toString(tr("hh:mm"))
               &lt;&lt; arrivalTime.toString(tr("hh:mm"))
               &lt;&lt; tr("%1 hr %2 min").arg(duration / 60)
                                    .arg(duration % 60)
               &lt;&lt; QString::number(changes)
               &lt;&lt; trainType;
        for (int i = 0; i &lt; fields.count(); ++i)
             tableWidget-&gt;setItem(row, i,
                                  new QTableWidgetItem(fields[i]));
        nextBlockSize = 0;
    }
}
</pre></div><br>
<p class="docText">The <tt>updateTableWidget()</tt> slot is connected to the <tt>QTcpSocket</tt>'s <tt>readyRead()</tt> signal, which is emitted whenever the <tt>QTcpSocket</tt> has received new data from the <a name="iddle1485"></a><a name="iddle1493"></a><a name="iddle2491"></a><a name="iddle5233"></a><a name="iddle5247"></a><a name="iddle5720"></a><a name="iddle6956"></a>server. The server sends us a list of possible train trips that match the user's criteria. Each matching trip is sent as a single block, and each block starts with a size. The <tt>forever</tt> loop is necessary because we don't necessarily get one block of data from the server at a time.<sup class="docFootnote"><a class="docLink" href="#ch14fn1">[*]</a></sup> We might have received an entire block, or just part of a block, or one and a half blocks, or even all of the blocks at once.</p><blockquote><p class="docFootnote"><sup><a name="ch14fn1">[*]</a></sup> The <tt>forever</tt> keyword is provided by Qt. It simply expands to <tt>for (;;)</tt>.</p></blockquote>
<a name="ch14fig02"></a><p><center>

<h5 class="docFigureTitle">Figure 14.2. The Trip Server's blocks</h5>

<p class="docText">
<img border="0" alt="" id="195131084199" width="500" height="59" SRC="images/tripserver_s.jpg"></p>

</center></P><br>
<p class="docText">So how does the <tt>forever</tt> loop work? If the <tt>nextBlockSize</tt> variable is 0, this means that we have not read the size of the next block. We try to read it (assuming there are at least 2 bytes available for reading). The server uses a size value of <tt>0xFFFF</tt> to signify that there is no more data to receive, so if we read this value, we know that we have reached the end.</p>
<p class="docText">If the block size is not <tt>0xFFFF</tt>, we try to read in the next block. First, we check to see if there are block size bytes available to read. If there are not, we stop there for now. The <tt>readyRead()</tt> signal will be emitted again when more data is available, and we will try again then.</P>
<p class="docText">Once we are sure that an entire block has arrived, we can safely use the <tt>&gt;&gt;</tt> operator on the <tt>QDataStream</tt> to extract the information related to a trip, and we create <tt>QTableWidgetItem</tt>s with that information. A block received from the server has the following format:</p>
<P><table cellspacing="0" class="allBorders" border="1" RULES="all" cellpadding="4"><colgroup align="left" span="2"><col width="75"><col width="200"></colgroup><thead></thead><TR><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint16</tt></P></td><td class="docTableCell" align="left" valign="top"><p class="docText">Block size in bytes (excluding this field)</P></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>QDate</tt></p></TD><td class="docTableCell" align="left" valign="top"><p class="docText">Departure date</p></TD></TR><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>QTime</tt></p></td><TD class="docTableCell" align="left" valign="top"><p class="docText">Departure time</p></td></TR><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint16</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Duration (in minutes)</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>quint8</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Number of changes</p></td></tr><tr><TD class="docTableCell" align="left" valign="top"><p class="docText"><tt>QString</tt></p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Train type</P></td></TR></table></P><br>
<p class="docText">At the end, we reset the <tt>nextBlockSize</tt> variable to 0 to indicate that the next block's size is unknown and needs to be read.</P>
<div class="docText"><pre>
void TripPlanner::closeConnection()
{
    tcpSocket.close();
    searchButton-&gt;setEnabled(true);
    stopButton-&gt;setEnabled(false);
    progressBar-&gt;hide();
}
</pre></div><br>
<p class="docText"><a name="iddle1595"></a><a name="iddle1956"></a><a name="iddle2179"></a><a name="iddle2333"></a><a name="iddle5227"></a><a name="iddle5238"></a><a name="iddle6580"></a><a name="iddle6641"></a><a name="iddle6958"></a><a name="iddle6959"></a><a name="iddle6961"></a><a name="iddle6964"></a><a name="iddle6965"></a><a name="iddle6969"></a>The <tt>closeConnection()</tt> private function closes the connection to the TCP server and updates the user interface. It is called from <tt>updateTableWidget()</tt> when the <tt>0xFFFF</tt> is read and from several other slots that we will cover shortly.</p>
<div class="docText"><pre>
void TripPlanner::stopSearch()
{
    statusLabel-&gt;setText(tr("Search stopped"));
    closeConnection();
}
</pre></div><BR>
<p class="docText">The <tt>stopSearch()</tt> slot is connected to the Stop button's <tt>clicked()</tt> signal. Essentially it just calls <tt>closeConnection()</tt>.</P>
<div class="docText"><pre>
void TripPlanner::connectionClosedByServer()
{
    if (nextBlockSize != 0xFFFF)
        statusLabel-&gt;setText(tr("Error: Connection closed by server"));
    closeConnection();
}
</pre></div><BR>
<p class="docText">The <tt>connectionClosedByServer()</tt> slot is connected to <tt>QTcpSocket</tt>'s <tt>disconnected()</tt> signal. If the server closes the connection and we have not yet received the <tt>0xFFFF</tt> end-of-data marker, we tell the user that an error occurred. We call <tt>closeConnection()</tt> as usual to update the user interface.</p>
<div class="docText"><pre>
void TripPlanner::error()
{
    statusLabel-&gt;setText(tcpSocket.errorString());
    closeConnection();
}
</pre></div><br>
<p class="docText">The <tt>error()</tt> slot is connected to <tt>QTcpSocket</tt>'s <tt>error(QAbstractSocket::SocketError)</tt> signal. We ignore the error code and use <tt>QTcpSocket::errorString()</tt>, which returns a human-readable error message for the last error that occurred.</p>
<p class="docText">This is all for the <tt>TRipPlanner</tt> class. The <tt>main()</tt> function for the Trip Planner application looks just as we would expect:</p>
<div class="docText"><pre>
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    TripPlanner tripPlanner;
    tripPlanner.show();
    return app.exec();
}
</pre></div><br>
<p class="docText">Now let's implement the server. The server consists of two classes: <tt>TRipServer</tt> and <tt>ClientSocket</tt>. The <tt>TRipServer</tt> class inherits <tt>QTcpServer</tt>, a class that allows us to accept incoming TCP connections. <tt>ClientSocket</tt> reimplements <tt>QTcpSocket</tt> and handles a single connection. At any one time, there are as many <tt>Client-Socket</tt> objects in memory as there are clients being served.</p>
<div class="docText"><pre>
class TripServer : public QTcpServer
{
    Q_OBJECT
public:
    TripServer(QObject *parent = 0);
private:
    void incomingConnection(int socketId);
};
</pre></div><br>
<p class="docText"><a name="iddle1466"></a><a name="iddle1467"></a><a name="iddle1468"></a><a name="iddle1957"></a><a name="iddle2818"></a><a name="iddle5230"></a><a name="iddle5239"></a><a name="iddle5242"></a><a name="iddle5248"></a><a name="iddle5251"></a><a name="iddle5721"></a><a name="iddle6185"></a><a name="iddle6642"></a><a name="iddle6966"></a><a name="iddle6967"></a>The <tt>tripServer</tt> class reimplements the <tt>incomingConnection()</tt> function from <tt>QTcpServer</tt>. This function is called whenever a client attempts to connect to the port the server is listening to.</p>
<div class="docText"><pre>
TripServer::TripServer(QObject *parent)
    : QTcpServer(parent)
{
}
</pre></div><BR>
<p class="docText">The <tt>tripServer</tt> constructor is trivial.</p>
<div class="docText"><pre>
void TripServer::incomingConnection(int socketId)
{
    ClientSocket *socket = new ClientSocket(this);
    socket-&gt;setSocketDescriptor(socketId);
}
</pre></div><BR>
<p class="docText">In <tt>incomingConnection()</tt>, we create a <tt>ClientSocket</tt> object as a child of the <tt>tripServer</tt> object, and we set its socket descriptor to the number provided to us. The <tt>ClientSocket</tt> object will delete itself automatically when the connection is terminated.</P>
<div class="docText"><pre>
class ClientSocket : public QTcpSocket
{
    Q_OBJECT
public:
    ClientSocket(QObject *parent = 0);
private slots:
    void readClient();
private:
    void generateRandomTrip(const QString &amp;from, const QString &amp;to,
                            const QDate &amp;date, const QTime &amp;time);
    quint16 nextBlockSize;
};
</pre></div><br>
<p class="docText">The <tt>ClientSocket</tt> class inherits from <tt>QTcpSocket</tt> and encapsulates the state of a single client.</p>
<div class="docText"><pre>
ClientSocket::ClientSocket(QObject *parent)
    : QTcpSocket(parent)
{
    connect(this, SIGNAL(readyRead()), this, SLOT(readClient()));
    connect(this, SIGNAL(disconnected()), this, SLOT(deleteLater()));
    nextBlockSize = 0;
}
</pre></div><br>
<p class="docText"><a name="iddle1340"></a><a name="iddle1470"></a><a name="iddle1486"></a><a name="iddle1906"></a><a name="iddle1958"></a><a name="iddle4152"></a><a name="iddle4604"></a><a name="iddle5231"></a><a name="iddle5234"></a><a name="iddle5240"></a><a name="iddle5249"></a><a name="iddle5692"></a><a name="iddle5722"></a>In the constructor, we establish the necessary signalslot connections, and we set the <tt>nextBlockSize</tt> variable to 0, indicating that we do not yet know the size of the block sent by the client.</p>
<p class="docText">The <tt>disconnected()</tt> signal is connected to <tt>deleteLater()</tt>, a <tt>QObject</tt>-inherited function that deletes the object when control returns to Qt's event loop. This ensures that the <tt>ClientSocket</tt> object is deleted when the socket connection is closed.</p>
<div class="docText"><pre>
void ClientSocket::readClient()
{
    QDataStream in(this);
    in.setVersion(QDataStream::Qt_4_1);
    if (nextBlockSize == 0) {
        if (bytesAvailable() &lt; sizeof(quint16))
            return;
        in &gt;&gt; nextBlockSize;
    }
    if (bytesAvailable() &lt; nextBlockSize)
        return;
    quint8 requestType;
    QString from;
    QString to;
    QDate date;
    QTime time;
    quint8 flag;
    in &gt;&gt; requestType;
    if (requestType == 'S') {
        in &gt;&gt; from &gt;&gt; to &gt;&gt; date &gt;&gt; time &gt;&gt; flag;
        srand(from.length() * 3600 + to.length() * 60 + time.hour());
        int numTrips = rand() % 8;
        for (int i = 0; i &lt; numTrips; ++i)
             generateRandomTrip(from, to, date, time);
        QDataStream out(this);
        out &lt;&lt; quint16(0xFFFF);
    }
    close();
}
</pre></div><br>
<p class="docText">The <tt>readClient()</tt> slot is connected to <tt>QTcpSocket</tt>'s <tt>readyRead()</tt> signal. If <tt>next-BlockSize</tt> is 0, we start by reading the block size; otherwise, we have already read it, and instead we check to see if a whole block has arrived. Once an entire block is ready for reading, we read it in one go. We use the <tt>QDataStream</tt> directly on the <tt>QTcpSocket</tt> (the <tt>this</tt> object) and read the fields using the <tt>&gt;&gt;</tt> operator.</p>
<p class="docText"><a name="iddle1157"></a><a name="iddle1293"></a><a name="iddle1469"></a><a name="iddle2539"></a><a name="iddle2693"></a><a name="iddle2907"></a><a name="iddle3093"></a><a name="iddle3120"></a><a name="iddle4366"></a><a name="iddle4367"></a><a name="iddle5243"></a><a name="iddle5253"></a><a name="iddle7314"></a>Once we have read the client's request, we are ready to generate a reply. If this were a real application, we would look up the information in a train schedule database and try to find matching train trips. But here we will be content with a function called <tt>generateRandomTrip()</tt> that will generate a random trip. We call the function a random number of times, and then we send <tt>0xFFFF</tt> to signify the end of the data. At the end, we close the connection.</p>
<div class="docText"><pre>
void ClientSocket::generateRandomTrip(const QString &amp; /* from */,
        const QString &amp; /* to */, const QDate &amp;date, const QTime &amp;time)
{
    QByteArray block;
    QDataStream out(&amp;block, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_4_1);
    quint16 duration = rand() % 200;
    out &lt;&lt; quint16(0) &lt;&lt; date &lt;&lt; time &lt;&lt; duration &lt;&lt; quint8(1)
        &lt;&lt; QString("InterCity");
    out.device()-&gt;seek(0);
    out &lt;&lt; quint16(block.size() - sizeof(quint16));
    write(block);
}
</pre></div><br>
<p class="docText">The <tt>generateRandomTrip()</tt> function shows how to send a block of data over a TCP connection. This is very similar to what we did in the client in the <tt>sendRequest()</tt> function (p. 326). Once again, we write the block to a <tt>QByteArray</tt> so that we can determine its size before we send it using <tt>write()</tt>.</p>
<div class="docText"><pre>
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    TripServer server;
    if (!server.listen(QHostAddress::Any, 6178)) {
        cerr &lt;&lt; "Failed to bind to port" &lt;&lt; endl;
        return 1;
    }
    QPushButton quitButton(QObject::tr("&amp;Quit"));
    quitButton.setWindowTitle(QObject::tr("Trip Server"));
    QObject::connect(&amp;quitButton, SIGNAL(clicked()),
                     &amp;app, SLOT(quit()));
    quitButton.show();
    return app.exec();
}
</pre></div><br>
<p class="docText">In <tt>main()</tt>, we create a <tt>tripServer</tt> object and a <tt>QPushButton</tt> that enables the user to stop the server. We start the server by calling <tt>QTcpSocket::listen()</tt>, which takes the IP address and port number on which we want to accept connections. The special address 0.0.0.0 (<tt>QHostAddress::Any</tt>) signifies any IP interface present on the local host.</p>
<p class="docText">This completes our clientserver example. In this case, we used a block-oriented protocol that allows us to use <tt>QDataStream</tt> for reading and writing. If we wanted to use a line-oriented protocol, the simplest approach would be to <a name="iddle1350"></a><a name="iddle2335"></a><a name="iddle2336"></a><a name="iddle2874"></a><a name="iddle4774"></a><a name="iddle5232"></a><a name="iddle5244"></a><a name="iddle5250"></a><a name="iddle5696"></a><a name="iddle5697"></a><a name="iddle5723"></a><a name="iddle6768"></a><a name="iddle6790"></a><a name="iddle6987"></a><a name="iddle7192"></a><a name="iddle7193"></a><a name="iddle7198"></a>use <tt>QTcpSocket</tt>'s <tt>canReadLine()</tt> and <tt>readLine()</tt> functions in a slot connected to the <tt>readyRead()</tt> signal:</p>
<div class="docText"><pre>
QStringList lines;
while (tcpSocket.canReadLine())
    lines.append(tcpSocket.readLine());
</pre></div><br>
<p class="docText">We would then process each line that has been read. As for sending data, that can be done using a <tt>QTextStream</tt> on the <tt>QTcpSocket</tt>.</P>
<p class="docText">The server implementation that we have used doesn't scale very well when there are lots of connections. The problem is that while we are processing a request, we don't handle the other connections. A more scalable approach would be to start a new thread for each connection. The Threaded Fortune Server example located in Qt's <tt>examples/network/threadedfortuneserver</tt> directory illustrates how to do this.</p>

</TD></TR></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec2.html><img src="images/prev.gif" width="60" height="17" border="0" align="absmiddle" alt="Previous Page"></a>
<td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href=ch14lev1sec4.html><img src="images/next.gif" width="60" height="17" border="0" align="absmiddle" alt="Next Page"></a>
</div></td></tr></table>
<div style="display:none"><center><a href="http://sourceforge.net/donate/index.php?group_id=186258"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" /> </a>|<script src='http://s34.cnzz.com/stat.php?id=626330&web_id=626330&show=pic2' language='JavaScript' charset='gb2312'></script></center></script></div></body></html>